import time
from datetime import datetime
from framework_constants import *
from lib_functions import *
from appium.webdriver.common.touch_action import TouchAction
from datetime import datetime,timedelta
## IOS Constants
import os
import subprocess
import time
from selenium.webdriver.common.keys import Keys
import datetime
from datetime import datetime
from appium import webdriver
from appium.webdriver.common.appiumby import AppiumBy
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC


class franklin_ios_testcases():
    def __init__(self, serial):
        self.serial = serial

    # 1
    def verify_franklin_launch_screen(self):
        '''
        This function verify that launching of franklin application
        :return:
        '''
        print(" Execution Started : verify_franklin_launch_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            output = driver.find_element(AppiumBy.IOS_PREDICATE,
                                         Ios_franklin_Constants.launch_screen_ios).is_displayed()
            if output:
                print("verify_franklin_launch_screen : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_franklin_launch_screen : FAIL")
                status = FAIL
                status_reason = "unable to launch the franklin application"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_franklin_launch_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 2
    def verify_franklin_login_screen(self):
        '''
        This function verify the launching the franklin login screen
        :return:
        '''
        print(" Execution Started : verify_franklin_login_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5525"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.loginscreen).click()
            result = driver.find_element(AppiumBy.IOS_PREDICATE,
                                         Ios_franklin_Constants.login_screen_check).is_displayed()
            if result:
                print("verify_franklin_login_screen : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_franklin_login_screen : FAIL")
                status = FAIL
                status_reason = "Unable to launch the login screen"

        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_franklin_login_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 3
    def verify_franklin_login_iOS_Invalid_UN(self):
        '''
        The function verify the franklin login with invalid username
        :return:
        '''
        print(" Execution Started : verify_franklin_login_iOS_Invalid_UN")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3428"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.loginscreen).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(Ios_franklin_Constants.Invalid_UN)
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            login_screen = driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.error).is_displayed()
            if login_screen:
                print("verify_franklin_login_iOS_Invalid_UN : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_franklin_login_iOS_Invalid_UN : FAIL")
                status = FAIL
                status_reason = "Error popup is not working"

        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_franklin_login_iOS_Invalid_UN ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 4
    def verify_franklin_register_user_enter_Invalid_UN(self):
        '''
        This function verify the error popup for invalid username
        :return:
        '''
        print(" Execution Started : verify_franklin_register_user_enter_Invalid_UN")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3439"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.loginscreen).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(Ios_franklin_Constants.Invalid_UN)
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            login_screen = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.error).is_displayed()
            if login_screen:
                print("verify_franklin_register_user_enter_Invalid_UN : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_franklin_register_user_enter_Invalid_UN : FAIL")
                status = FAIL
                status_reason = "Error popup is not apper on the screen"

        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_franklin_register_user_enter_Invalid_UN ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 5
    def verify_franklin_login_iOS_Invalid_PW(self):
        '''
        This function verify the franklin login with invalid password
        :return:
        '''
        print(" Execution Started : verify_franklin_login_iOS_Invalid_PW")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5639"
        driver = desired_caps_IOS(self.serial)
        time.sleep(3)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.loginscreen).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys('Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_password).send_keys(
                Ios_franklin_Constants.Invalid_PW)
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.loginscreen).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_click_on_login).click()
            time.sleep(3)
            login_screen = driver.find_element(AppiumBy.IOS_PREDICATE,
                                               Ios_franklin_Constants.invalid_pwd).is_displayed()
            if login_screen:
                print("verify_franklin_login_iOS_Invalid_PW : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_franklin_login_iOS_Invalid_PW : FAIL")
                status = FAIL
                status_reason = "Error popup is not apper on the screen"

        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_franklin_login_iOS_Invalid_PW ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 6
    def verify_franklin_register_user_enter_wrong_PW(self):
        '''
        This functiion verify the login with registered user with wrong password
        :return:
        '''
        print("")
        print(" Execution Started : verify_franklin_register_user_enter_wrong_PW")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3369"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.loginscreen).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys('Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_password).send_keys(
                Ios_franklin_Constants.Invalid_PW)
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.loginscreen).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_click_on_login).click()
            time.sleep(2)
            login_screen = driver.find_element(AppiumBy.IOS_PREDICATE,
                                               Ios_franklin_Constants.invalid_pwd).is_displayed()
            if login_screen:
                print("verify_franklin_register_user_enter_wrong_PW : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_franklin_register_user_enter_wrong_PW : FAIL")
                status = FAIL
                status_reason = "Error popup is not apper on the screen"

        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_franklin_register_user_enter_wrong_PW ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_login_text_login_email_conf_screen(self):
        '''
        This function verify the franklin application
        :return:
        '''
        print(" Execution Started : verify_login_text_login_email_conf_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5525"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.loginscreen).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys('Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            login_screen=driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.loginscreen).text
            if login_screen== "Login":
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not login"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_login_text_login_email_conf_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_email_text_login_email_conf_screen(self):
        '''
        This function verify the franklin application
        :return:
        '''
        print(" Execution Started : verify_email_text_login_email_conf_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5529"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            login_screen = driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.email_text_login).text
            if login_screen == 'Email':
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not login"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_email_text_login_email_conf_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_email_field_login_email_conf_screen(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_email_field_login_email_conf_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5526"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_PREDICATE,
                                         Ios_franklin_Constants.login_screen_email).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_email_field_login_email_conf_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_submit_button_login_email_conf_screen(self):
        '''
        This function verify the franklin application
        :return:
        '''
        print(" Execution Started : verify_submit_button_login_email_conf_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5531"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.loginscreen).click()
            time.sleep(2)
            login_screen=driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).is_displayed()
            if login_screen:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not login"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_submit_button_login_email_conf_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 7
    def verify_franklin_login_iOS(self):
        '''
        This function verify the franklin application
        :return:
        '''
        print(" Execution Started : verify_franklin_login_iOS")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            # try:
            #     login_screen=driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.recordentry_1).is_displayed()
            #     if login_screen:
            #         print("verify_franklin_login_iOS : PASS")
            #         status = PASS
            #         status_reason =  TEST_SUCCESSFUL
            #     else:
            #         print("verify_franklin_login_iOS : FAIL")
            #         status = FAIL
            #         status_reason = "Application not login"
            # except:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.loginscreen).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys('Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_password).send_keys(
                'Setha@21')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.loginscreen).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_click_on_login).click()
            time.sleep(1)
            login_screen=driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.recordentry_1).is_displayed()
            if login_screen:
                print("verify_franklin_login_iOS : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_franklin_login_iOS : FAIL")
                status = FAIL
                status_reason = "Application not login"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_franklin_login_iOS ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 08
    def verify_username_in_dashboard(self):
        '''
        This function verify the username in dashboard
        :return:
        '''
        print(" Execution Started : verify_username_in_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4817"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.user_name).is_displayed()
            if goal:
                print("verify_username_in_dashboard : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_username_in_dashboard : FAIL")
                status = FAIL
                status_reason = "Not able to check username in dashboard "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_username_in_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 09
    def verify_menu_dashboard(self):
        '''
        This function verify the menu dashboard
        :return:
        '''
        print(" Execution Started : verify_menu_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4808"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Menu_screen).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not display menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_menu_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 010
    def verify_dashboard_meplus(self):
        '''
        This function verify the meplus of the dashboard
        :return:
        '''
        print(" Execution Started : verify_dashboard_meplus")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4699"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.me_plus).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.convatec_logo).is_displayed()
            if goal:
                print("verify_dashboard_meplus : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_dashboard_meplus : FAIL")
                status = FAIL
                status_reason = "Application not display meplus"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_dashboard_meplus ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 011
    def verify_dashboard_summary(self):
        '''
        This function verify summary in dashboard
        :return:
        '''
        print(" Execution Started : verify_dashboard_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4811"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy).is_displayed()
            if goal:
                print("verify_dashboard_summary : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_dashboard_summary : FAIL")
                status = FAIL
                status_reason = "Application not display summary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_dashboard_summary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 012
    def verify_summary_dashboard(self):
        '''
        This function verify the dashboard summary
        :return:
        '''
        print(" Execution Started : verify_summary_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4810"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not display dashboard summary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_summary_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 013
    def verify_meplus_dashboard(self):
        '''
        This function verify the dashboard meplus
        :return:
        '''
        print(" Execution Started : verify_meplus_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4812"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.me_plus).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.home).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.user_name).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not display dashboard meplus"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_meplus_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 014
    def verify_dashboard_menu(self):
        '''
        This function verify the dashboard menu
        :return:
        '''
        print(" Execution Started : verify_dashboard_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4813"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.home).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.user_name).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not display dashboard menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_dashboard_menu ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 015
    def verify_meplus_menu(self):
        '''
        This function verify the meplus to menu
        :return:
        '''
        print(" Execution Started : verify_meplus_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4702"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.me_plus).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.convatec_logo).is_displayed()
            if goal:
                print("verify_meplus_menu : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_meplus_menu : FAIL")
                status = FAIL
                status_reason = "Application not display menu plus to mrnu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            # print("verify_franklin_installation", status, testcase_execution_time)
            testcase_execution_time = execution_time(tc_start_time)
            print(az_id, "verify_meplus_menu ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 016
    def verify_set_hydration_goal(self):
        '''
        This function verify setting hydration goal
        :return:
        '''
        print(" Execution Started : verify_set_hydration_goal")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5867"
        driver = desired_caps_IOS(self.serial)
        print("after desired caps")
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.set_goal_send_keys).send_keys('499')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.ok_button).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.recordentry_1).is_displayed()
            if goal:
                print("verify_set_hydration_goal : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_set_hydration_goal : FAIL")
                status = FAIL
                status_reason = "Not able to set hydration"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_hydration_goal ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 017
    def verify_cancel_hydration_goal_settings_screen(self):
        '''
        The function verify the cancel hydration goal without goal
        :return:
        '''
        print(" Execution Started : verify_cancel_hydration_goal_settings_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5865"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.cancel_goal).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_cancel_hydration_goal_settings_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 018
    def verify_set_hydration_goal_by_user(self):
        '''
        This function verify setting hydration goal with user selection
        :return:
        '''
        print(" Execution Started : verify_set_hydration_goal_by_user")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5860"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.enter_goal).send_keys('357')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).click()
            driver.implicitly_wait(6)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                print("verify_set_hydration_goal_by_user : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_set_hydration_goal_by_user : FAIL")
                status = FAIL
                status_reason = "Not able to set hydration"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_hydration_goal_by_user ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 019
    def verify_record_entery_for_void(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_for_void")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3383"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('3')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('4')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                print("verify_record_entry_for_void : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_record_entry_for_void : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entery_for_void ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 020
    def verify_record_entry_for_void_catheter(self):
        '''
        This function verify record entry for catheter
        :return:
        '''
        print(" Execution Started : verify_record_entry_for_void_catheter")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4866"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('50')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for catheter"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_for_void_catheter ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 021
    def verify_record_entry_for_void_natural(self):
        '''
        This function verify the record entry for natural
        :return:
        '''
        print(" Execution Started : verify_record_entry_for_void_natural")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4865"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('45')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                print("verify_record_entry_for_void_natural : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_record_entry_for_void_natural : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry for natural"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_for_void_natural ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 022
    def verify_beverage_highlight_tea(self):
        '''
        This function verify the intake fluid highlight tea
        :return:
        '''
        print(" Execution Started : verify_beverage_highlight_tea")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4694"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.coffee).click()
            time.sleep(1)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to select tea in fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_highlight_tea ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 023
    def verify_record_entry_for_beverage(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_record_entry_for_beverage")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4867"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.coffee).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.water).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage_save).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for beverage"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_for_beverage ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 024
    def verify_record_entry_for_beverage_water(self):
        '''
        This function verify the beverage value with water
        :return:
        '''
        print(" Execution Started : verify_record_entry_for_beverage_water")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4694"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.water).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage_save).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for beverage"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_for_beverage_water ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 025
    def verify_record_entry_for_beverage_input(self):
        '''
        This function verify the record a entry for beverage input
        :return:
        '''
        print(" Execution Started : verify_record_entry_for_beverage_input")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4694"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.coffee).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.More).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.water_units).send_keys('60')
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.hide).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage_save).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for beverage input"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_for_beverage_input ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 026
    def verify_daysummary(self):
        '''
        This function verify the day summary
        :return:
        '''
        print(" Execution Started : verify_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4585"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.day).is_displayed()
            if goal:
                print("verify_daysummary : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_daysummary : FAIL")
                status = FAIL
                status_reason = "Not able to check day summary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 027
    def verify_Day_summary_urine_currentdate(self):
        '''
        This function verify the day summary urine value
        :return:
        '''
        print(" Execution Started : verify_Day_summary_urine_currentdate")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4581"
        driver = desired_caps_IOS(self.serial)
        time.sleep(7)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('3')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('4')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for urine data "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Day_summary_urine_currentdate ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 028
    def verify_Day_summary_fluid_currentdate(self):
        '''
        This function verify the fluid intake for day summary
        :return:
        '''
        print(" Execution Started : verify_Day_summary_fluid_currentdate")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4581"
        driver = desired_caps_IOS(self.serial)
        time.sleep(7)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.coffee).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.water).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage_save).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).is_displayed()
            if goal:
                print("verify_Day_summary_fluid_currentdate : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_Day_summary_fluid_currentdate : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry for fluid"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Day_summary_fluid_currentdate ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 029
    def verify_Day_summary_beverage_change_fluid(self):
        '''
        This function verify the beverage with change fluid
        :return:
        '''
        print(" Execution Started : verify_Day_summary_beverage_change_fluid")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4045"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.water).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.hide).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage_save).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                       Ios_franklin_Constants.verify_entry).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for change fluid"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Day_summary_beverage_change_fluid ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 030
    def verify_week_summary_Ios_franklin(self):
        '''
        This function verify the week summary
        :return:
        '''
        print(" Execution Started : verify_week_summary_Ios_franklin")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4811"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.coffee).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.water).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage_save).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.day_in_week).click()
            time.sleep(2)
            # driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.current_entry).click()
            # time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.total_data).is_displayed()
            if goal:
                print("verify_week_summary_Ios_franklin : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_week_summary_Ios_franklin : FAIL")
                status = FAIL
                status_reason = "Not able to check week summary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_week_summary_Ios_franklin ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 031
    def verify_urine_void_of_day_in_week_summary(self):
        '''
        This function verify the urine data in date for week summary
        :return:
        '''
        print(" Execution Started : verify_urine_void_of_day_in_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4811"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('30')
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('40')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.day_in_week).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.total_data).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to check urine data in date for week summary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_urine_void_of_day_in_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 032
    def verify_month_summary(self):
        '''
        This function verify the month summary
        :return:
        '''
        print(" Execution Started : verify_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4811"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.dropdown).click()
            time.sleep(7)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).is_displayed()
            if goal:
                print("verify_month_summary : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_month_summary : FAIL")
                status = FAIL
                status_reason = "Not able to check month summary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 033
    def verify_current_month_default_in_month_summary(self):
        '''
        This function verify the month summary
        :return:
        '''
        print(" Execution Started : verify_current_month_default_in_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4687"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).is_displayed()
            if goal:
                print("verify_current_month_default_in_month_summary : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_current_month_default_in_month_summary : FAIL")
                status = FAIL
                status_reason = "Not able to check month summary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_month_default_in_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 034
    def verify_custom_summary(self):
        '''
        This function verify the custom summary
        :return:
        '''
        print(" Execution Started : verify_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4689"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.dropdown).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Apply).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).is_displayed()
            if goal:
                print("verify_custom_summary : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_custom_summary : FAIL")
                status = FAIL
                status_reason = "Not able to select custom summary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 035
    def verify_creating_custom_summary(self):
        '''
        This function verify the creating a custom summary
        :return:
        '''
        print(" Execution Started : verify_creating_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4685"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Indetail_day_in_custom).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.total_data).is_displayed()
            if goal:
                print("verify_creating_custom_summary : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_creating_custom_summary : FAIL")
                status = FAIL
                status_reason = "Not able to creat a custom summary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_creating_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 036
    def verify_restricts_end_custom_summary(self):
        '''
        This function verify the end date of custom summary
        :return:
        '''
        print(" Execution Started : verify_restricts_end_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4691"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(8)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.dropdown).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(8)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date1).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.end_date).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).is_displayed()
            if goal:
                print("verify_restricts_end_custom_summary : PASS")
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_restricts_end_custom_summary : FAIL")
                status = FAIL
                status_reason = "Not able to check end date of custom summary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_restricts_end_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 037

    def verify_meplus_summary(self):
        '''
        This function verify the meplus summary
        :return:
        '''
        print(" Execution Started : verify_meplus_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4701"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.me_plus).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.convatec_logo).is_displayed()
            if goal:
                print("verify_meplus_summary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_meplus_summary : FAIL")
                status = FAIL
                status_reason = "not able to navigate from meplus to summary"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_meplus_summary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 038

    def verify_summary_meplus(self):
        '''
        This function verify the summary to  meplus
        :return:
        '''
        print(" Execution Started : verify_summary_meplus")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4814"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.me_plus).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.convatec_logo).is_displayed()
            if goal:
                print("verify_summary_meplus : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_summary_meplus : FAIL")
                status = FAIL
                status_reason = "Not able to navigate from summary to meplus"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_summary_meplus ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 039
    def verify_summary_menu(self):
        '''
        This function verify the summary to menu
        :return:
        '''
        print(" Execution Started : verify_summary_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4815"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Menu_screen).is_displayed()
            if goal:
                print("verify_summary_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_summary_menu : FAIL")
                status = FAIL
                status_reason = "not able to navigate from summary to menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_summary_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 040

    def verify_menu_summary(self):
        '''
        This function verify the menu to summary
        :return:
        '''
        print(" Execution Started : verify_menu_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4809"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy).is_displayed()
            if goal:
                print("verify_menu_summary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_menu_summary : FAIL")
                status = FAIL
                status_reason = "not able to navigate from menu to summary"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_menu_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 041
    def verify_menu_meplus(self):
        '''
        This function verify the meplus to menu
        :return:
        '''
        print(" Execution Started : verify_menu_meplus")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4816"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.me_plus).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.convatec_logo).is_displayed()
            if goal:
                print("verify_menu_meplus : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_menu_meplus : FAIL")
                status = FAIL
                status_reason = "not able to navigate from menu to meplus"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_menu_meplus ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 042

    def verify_goal_value_dashboard(self):
        '''
        This function verify  goal value dashboard
        :return:
        Franklin application displays goal value in dashboard
        '''
        print(" Execution Started : verify_goal_value_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4835"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.set_goal_send_keys).send_keys('100')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(5)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dailygoal_value).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to verify goal value dashboard"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_goal_value_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_set_goal_msg_dashboard(self):
        '''
        This function verify the track message dashboard
        :return:
        '''
        print(" Execution Started : verify_set_goal_msg_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4834"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.track_urine_message).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to track msg dashboard"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_goal_msg_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_void_number_dashboard(self):
        '''
        This function verify the track message dashboard
        :return:
        '''
        print(" Execution Started : verify_void_number_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5734"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.Totale_void_data).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to track msg dashboard"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_void_number_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_void_volume_dashboard(self):
        '''
        This function verify the track message dashboard
        :return:
        '''
        print(" Execution Started : verify_void_volume_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5733"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.Totale_void_data).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to track msg dashboard"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_void_volume_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason
    # 043

    def verify_precent_complete_dashboard(self):
        '''
        This function verify percent complete dashboard
        :return:
        application displays percentage goal completed on dashboard
        '''
        print(" Execution Started : verify_precent_complete_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4832"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.set_goal_send_keys).send_keys('100')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.percentage).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to verify percent complete dashboard"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_precent_complete_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_beverage_volume_dashboard(self):
        '''
        This function verify percent complete dashboard
        :return:
        application displays percentage goal completed on dashboard
        '''
        print(" Execution Started : verify_beverage_volume_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5732"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.dashboard_urine)
            time.sleep(2)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(5)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.beverage_complete).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to verify percent complete dashboard"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_volume_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_existing_beverage_volume_dashboard(self):
        '''
        This function verify percent complete dashboard
        :return:
        application displays percentage goal completed on dashboard
        '''
        print(" Execution Started : verify_existing_beverage_volume_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3333"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(5)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.beverage_complete).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to verify percent complete dashboard"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_existing_beverage_volume_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_current_date_dashboard(self):
        '''
        This function verify percent complete dashboard
        :return:
        application displays percentage goal completed on dashboard
        '''
        print(" Execution Started : verify_current_date_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5723"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.home_date).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to verify date dashboard"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_date_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 044

    def verify_progress_bar_dashboard(self):
        '''
        This function verify the progress bar dashboard
        :return:
        '''
        print(" Execution Started : verify_progress_bar_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4831"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.set_goal_send_keys).send_keys('100')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.progress_bar).is_displayed()
            if goal:
                print("verify_progress_bar_dashboard : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_progress_bar_dashboard : FAIL")
                status = FAIL
                status_reason = "not able to verify progress bar in dashboard"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_progress_bar_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 045

    def verify_goal_volume_units(self):
        '''
        This function verify the goal volume units
        :return:
        '''
        print(" Execution Started : verify_goal_volume_units")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4819"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                       Ios_franklin_Constants.voided_volume_units).is_displayed()
            if goal:
                print("verify_goal_volume_units : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_goal_volume_units : FAIL")
                status = FAIL
                status_reason = "not able to verify goal volume units"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_goal_volume_units ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 046

    def verify_intake_volume_units(self):
        '''
        This function verify intake volume units
        :return:
        '''
        print(" Execution Started : verify_intake_volume_units")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4820"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                       Ios_franklin_Constants.voided_volume_intake_units).is_displayed()
            if goal:
                print("verify_intake_volume_units : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_intake_volume_units : FAIL")
                status = FAIL
                status_reason = "not able to verify intake volume units"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_intake_volume_units ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 047

    def verify_track_msg_dashboard(self):
        '''
        This function verify the track message dashboard
        :return:
        '''
        print(" Execution Started : verify_track_msg_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4818"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.track_urine_message).is_displayed()
            if goal:
                print("verify_track_msg_dashboard : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_track_msg_dashboard : FAIL")
                status = FAIL
                status_reason = "not able to track msg dashboard"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_track_msg_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 048
    def verify_update_goal_value_dashboard(self):
        '''
        This function verify the update goal value dashboard
        :return:
        '''
        print(" Execution Started : verify_update_goal_value_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4833"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(5)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy_goal).is_displayed()
            if goal:
                print("verify_update_goal_value_dashboard : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_update_goal_value_dashboard : FAIL")
                status = FAIL
                status_reason = "not able to update goal value dashboard"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_update_goal_value_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 049
    def verify_set_goal_msg_dashboard(self):
        '''
        This function verify the set goal msg dashboard
        :return:
        '''
        print(" Execution Started : verify_set_goal_msg_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5869"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.track_urine_message).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to verify set goal msg dashboard"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_goal_msg_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 050

    def verify_set_goal_option_dashboard(self):
        '''
        This function verify the set goal option dashboard
        :return:
        '''
        print(" Execution Started : verify_set_goal_option_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4858"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to set goal option dashboard"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_goal_option_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 051

    def verify_record_entry_option_dashboard(self):
        '''
        This function verify the record entry option dashboard
        :return:
        '''
        print(" Execution Started : verify_record_entry_option_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4859"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.recordentry_1).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to verify record entry option dashboard"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_option_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 052

    def verify_default_unit_selection_void_entry(self):
        '''
        This function verify the default unit selection void entry
        :return:
        '''
        print(" Execution Started : verify_default_unit_selection_void_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4860"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.recordentry_1).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                       Ios_franklin_Constants.urine_oz_text).is_displayed()
            if goal:
                print("verify_default_unit_selection_void_entry : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_default_unit_selection_void_entry : FAIL")
                status = FAIL
                status_reason = "not able to verify default unit selection void entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_default_unit_selection_void_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 053
    def verify_ml_oz_void_entry(self):
        '''
        This function verify the ml oz void entry
        :return:
        '''
        print(" Execution Started : verify_ml_oz_void_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4861"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.recordentry_1).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE,
                                       Ios_franklin_Constants.OZ).is_displayed()
            if goal:
                print("verify_ml_oz_void_entry : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_ml_oz_void_entry : FAIL")
                status = FAIL
                status_reason = "not able to verify ml to oz void entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_ml_oz_void_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 054
    def verify_oz_ml_void_entry(self):
        '''
        This function verify the oz ml void entry
        :return:
        '''
        print(" Execution Started : verify_oz_ml_void_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4862"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.recordentry_1).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ml_click).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.ml_check).is_displayed()
            if goal:
                print("verify_oz_ml_void_entry : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_oz_ml_void_entry : FAIL")
                status = FAIL
                status_reason = "Application not display menu plus to mrnu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_oz_ml_void_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 055
    def verify_default_unit_oz_void_entry(self):
        '''
        This function verify the default unit oz void entry
        :return:
        '''
        print(" Execution Started : verify_default_unit_oz_void_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4863"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.OZ).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                       Ios_franklin_Constants.catheter_oz_check).is_displayed()
            if goal:
                print("verify_default_unit_oz_void_entry : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_default_unit_oz_void_entry : FAIL")
                status = FAIL
                status_reason = "not able to verify default unit oz void entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_default_unit_oz_void_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 056
    def verify_default_unit_ml_void_entry(self):
        '''
        This function verify the default uinit void entry
        :return:
        '''
        print(" Execution Started : verify_default_unit_ml_void_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4864"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.ml_check).is_displayed()
            if goal:
                print("verify_default_unit_ml_void_entry : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_default_unit_ml_void_entry : FAIL")
                status = FAIL
                status_reason = "not able to verify default unit ml void entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_default_unit_ml_void_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 057
    def verify_current_day_void_record_entry(self):
        '''
        This function verify the current day void record entry
        :return:
        '''
        print(" Execution Started : verify_current_day_void_record_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4865"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today).is_displayed()
            if goal:
                print("verify_current_day_void_record_entry : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_current_day_void_record_entry : FAIL")
                status = FAIL
                status_reason = "not able to verify current day void record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_day_void_record_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 058
    def verify_current_time_void_record_entry(self):
        '''
        This function verify the current time void record entry
        :return:
        '''
        print(" Execution Started : verify_current_time_void_record_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4866"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.current_time).is_displayed()
            if goal:
                print("verify_current_time_void_record_entry : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_current_time_void_record_entry : FAIL")
                status = FAIL
                status_reason = "not able to verify current time void record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_time_void_record_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 059
    def verify_current_day_beverage_record_entry(self):
        '''
        This function verify the current day beverage record entry
        :return:
        '''
        print(" Execution Started : verify_current_day_beverage_record_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4865"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.beverage_icon).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today).is_displayed()
            if goal:
                print("verify_current_day_beverage_record_entry : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_current_day_beverage_record_entry : FAIL")
                status = FAIL
                status_reason = "not able to set current day day beverage record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_day_beverage_record_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 060
    def verify_current_time_beverage_record_entry(self):
        '''
        This function verify the current time beverage record entry
        :return:
        '''
        print(" Execution Started : verify_current_time_beverage_record_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4868"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.beverage_icon).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.current_time).is_displayed()
            if goal:
                print("verify_current_time_beverage_record_entry : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_current_time_beverage_record_entry : FAIL")
                status = FAIL
                status_reason = "not able to set current time beverage record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_time_beverage_record_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 061
    def verify_current_day_leak_record_entry(self):
        '''
        This function verify the current day leak record entry
        :return:
        '''
        print(" Execution Started : verify_current_day_leak_record_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6014"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.ok_button).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to set current day leak record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_day_leak_record_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 062
    def verify_current_time_leak_record_entry(self):
        '''
        This function verify the current time leak record entry
        :return:
        '''
        print(" Execution Started : verify_current_time_leak_record_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4870"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.ok_button).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).is_displayed()
            if goal:
                print("verify_current_time_leak_record_entry : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_current_time_leak_record_entry : FAIL")
                status = FAIL
                status_reason = "not able to verify current time leak record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_time_leak_record_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 063

    def verify_void_record_entry(self):
        '''
        This function verify the void record entry
        :return:
        '''
        print(" Execution Started : verify_void_record_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4864"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                       Ios_franklin_Constants.default_urine_voided).is_displayed()
            if goal:
                print("verify_void_record_entry : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_void_record_entry : FAIL")
                status = FAIL
                status_reason = "not able to set void record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_void_record_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 064

    def verify_beverage_record_entry(self):
        '''
        This function verify the beverage record entry
        :return:
        '''
        print(" Execution Started : verify_beverage_record_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4867"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.beverage_record_entry1).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.beverage_name).is_displayed()
            if goal:
                print("verify_beverage_record_entry : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_beverage_record_entry : FAIL")
                status = FAIL
                status_reason = "not able to verify beverage record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_record_entry ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 065

    def verify_leak_record_entry(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_leak_record_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6466"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save_menu).click()
            time.sleep(2)
            leak = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_success_toast).is_displayed()
            if leak:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to verify leak record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_leak_record_entry ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_date_time_heading_leak(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_date_time_heading_leak")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7878"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).text
            if goal == 'Date & Time':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to verify leak record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_date_time_heading_leak ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_comments_heading_leak(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_comments_heading_leak")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7877"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to verify leak record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_heading_leak ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_comments_input_text_leak(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_comments_input_text_leak")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7876"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.enter_in_comments).send_keys('leak record entry')
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).text
            if goal == 'Comments':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to verify leak record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_input_text_leak ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_save_text_leak(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_save_text_leak")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7880"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            save = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save_menu).text
            if save == 'SAVE':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to verify leak record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_save_text_leak ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_leak_title_record_entry(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_leak_title_record_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4885"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to verify leak record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_leak_title_record_entry ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 066

    def verify_set_hydration_goal_random_value_menu(self):
        '''
        This function verify the set hydration goal by random value
        :return:
        '''
        print(" Execution Started : verify_set_hydration_goal_random_value_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5862"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.set_goal_send_keys).send_keys('200')
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal_key).is_displayed()
            if goal:
                print("verify_set_hydration_goal_random_value_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_set_hydration_goal_random_value_menu : FAIL")
                status = FAIL
                status_reason = "not able to set hydration goal by random value"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_hydration_goal_random_value_menu ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 067

    def verify_set_hydration_goal_by_user_input_menu(self):
        '''
        This function verify the set hydration goal by user input menu
        :return:
        '''
        print(" Execution Started : verify_set_hydration_goal_by_user_input_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5872"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.set_goal_send_keys).send_keys('499')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.ok_button).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.recordentry_1).is_displayed()
            if goal:
                print("verify_set_hydration_goal_by_user_input_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_set_hydration_goal_by_user_input_menu : FAIL")
                status = FAIL
                status_reason = "Not able to set hydration goal by user input menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_hydration_goal_by_user_input_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 068

    def verify_set_hydration_goal_on_selection_menu(self):
        '''
        This function verify the set hydration goal; on selection menu
        :return:
        '''
        print(" Execution Started : verify_set_hydration_goal_on_selection_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5864"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.set_goal_send_keys).send_keys('49')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.ok_button).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.recordentry_1).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration goal in selection menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_hydration_goal_on_selection_menu ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 069

    def verify_user_exit_without_goal_set_menu(self):
        '''
        This function verify the user exit without goal setting menu
        :return:
        '''
        print(" Execution Started : verify_user_exit_without_goal_set_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5865"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            goal_1 = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dailygoal_value).text
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.set_goal_cancel_key).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dailygoal_value).text
            if goal == goal_1:
                print("verify_user_exit_without_goal_set_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_user_exit_without_goal_set_menu : FAIL")
                status = FAIL
                status_reason = "user not able to exit without goal set menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_user_exit_without_goal_set_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 070

    def verify_goal_value_dashboard_menu(self):
        '''
        This function verify the goal value in dashboard menu
        :return:
        '''
        print(" Execution Started : verify_goal_value_dashboard_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5867"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_user_input_menu).send_keys('50')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dailygoal_value).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "not able to verify goal value dashboard menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_goal_value_dashboard_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 071

    def verify_record_entry_for_void_previous(self):
        '''
        This function verify the record entry for void previous
        :return:
        '''
        print(" Execution Started : verify_record_entry_for_void_previous")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3385"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(1)
            date = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today)
            time.sleep(1)
            print(date.text)
            date.click()
            previous_date = (datetime.datetime.now() - datetime.timedelta(1)).strftime("%B %d %Y")
            print(previous_date)
            dat = previous_date.split(" ")[1]
            print(dat)
            if dat[0] == "0":
                dat = dat[1:]
                print("date ::::", dat)
            dateq = driver.find_element("xpath", f'//XCUIElementTypeStaticText[@name="{dat}"]')
            print(dateq.text)
            dateq.click()
            print(dateq.text)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('30')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('40')
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.daysummary_back).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.data_content).is_displayed()
            if goal:
                print("verify_record_entry_for_void_previous : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_record_entry_for_void_previous : FAIL")
                status = FAIL
                status_reason = "not able to verify record entry for void previous"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_for_void_previous ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 072
    def verify_Day_summary_modified_beverage_volume(self):
        '''
        This function verify the day summary modified beveraage volume
        :return:
        '''
        print(" Execution Started : verify_Day_summary_modified_beverage_volume")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4696"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.alcohol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.more_plus).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.taken_water).send_keys('250')
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.hide).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage_save).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE,
                                       Ios_franklin_Constants.latest_input_water_record).is_displayed()
            if goal:
                print("verify_Day_summary_modified_beverage_volume : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_Day_summary_modified_beverage_volume : FAIL")
                status = FAIL
                status_reason = "Not able to verify day summary modified beverage volume"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Day_summary_modified_beverage_volume ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 073
    def verify_record_entry_for_void_future(self):
        '''
                This function verify the record entry for void future
                :return:
                '''
        print(" Execution Started : verify_record_entry_for_void_future")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4586"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('30')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('40')
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).click()
            time.sleep(1)
            date = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today)
            time.sleep(1)
            print(date.text)
            date.click()
            Future = (datetime.datetime.now() + datetime.timedelta(1)).strftime("%d %B %Y")
            # print("dfghjk",Future)
            # a=driver.find_element("xpath", f'//XCUIElementTypeButton[@name="{Future}"]')
            # print(a,"eeee")
            if Future:
                print("verify_record_entry_for_void_future : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_record_entry_for_void_future : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry for void future "
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_for_void_future ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 074
    def verify_record_entry_for_void_catheter_future(self):
        '''
                This function verify the record entry for void future
                :return:
                '''
        print(" Execution Started : verify_record_entry_for_void_catheter_future")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4896"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('30')
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).click()
            time.sleep(1)
            date = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today)
            time.sleep(1)
            print(date.text)
            date.click()
            Future = (datetime.datetime.now() + datetime.timedelta(1)).strftime("%d %B %Y")
            # print("dfghjk",Future)
            # a=driver.find_element("xpath", f'//XCUIElementTypeButton[@name="{Future}"]')
            # print(a,"eeee")
            if Future:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for urine data "
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_for_void_catheter_future ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 075
    def verify_record_entry_for_void_natural_future(self):
        '''
                This function verify the record entry for void natural future
                :return:
                '''

        print(" Execution Started : verify_record_entry_for_void_natural_future")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('40')
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).click()
            time.sleep(1)
            date = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today)
            time.sleep(1)
            print(date.text)
            date.click()
            Future = (datetime.datetime.now() + datetime.timedelta(1)).strftime("%d %B %Y")
            # print("dfghjk",Future)
            # a=driver.find_element("xpath", f'//XCUIElementTypeButton[@name="{Future}"]')
            # print(a,"eeee")
            if Future:
                print("verify_record_entry_for_void_natural_future : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_record_entry_for_void_natural_future : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry for  void natural future data "
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_for_void_natural_future ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 076
    def verify_record_entry_for_beverage_future(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_record_entry_for_beverage_future")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            date = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today)
            time.sleep(1)
            date.click()
            Future = (datetime.datetime.now() + datetime.timedelta(1)).strftime("%d %B %Y")
            if Future:
                print("verify_record_entry_for_beverage_future : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_record_entry_for_beverage_future : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry for beverage future"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_for_beverage_future ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 077
    def verify_record_entry_for_beverage_random_future(self):
        '''
        This function verify the record entry for beverage random future
        :return:
        '''
        print(" Execution Started : verify_record_entry_for_beverage_random_future")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.coffee).click()
            time.sleep(2)
            date = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today)
            time.sleep(1)
            print(date.text)
            date.click()
            Future = (datetime.datetime.now() + datetime.timedelta(1)).strftime("%d %B %Y")
            if Future:
                print("verify_record_entry_for_beverage_random_future : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_record_entry_for_beverage_random_future : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry for beverage random future"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_for_beverage_random_future ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 078
    def verify_day_summary_void_both_entry(self):
        '''
        This function verify the day summary void both entry
        :return:
        '''
        print(" Execution Started : verify_day_summary_void_both_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4581"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            cath = '4'
            nat = '5'
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys(cath)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys(nat)
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            catheter_value = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.sum_cath)
            natural_value = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.sum_nat)
            print(catheter_value.text)
            print(catheter_value.text == (cath + ' ml'))  # & natural_value.text == (nat+' ml'))
            if catheter_value.text == (cath + ' ml'):
                print(" verify_day_summary_void_both_entry: PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_day_summary_void_both_entry : FAIL")
                status = FAIL
                status_reason = "Not able to verify day summary void entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_day_summary_void_both_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 079
    def verify_day_summary_void_cath_entry(self):
        '''
        This function verify the day summary void catheter entry
        :return:
        '''
        print(" Execution Started : verify_day_summary_void_cath_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4581"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            cath = '4'
            nat = '5'
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys(cath)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys(nat)
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            catheter_value = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.sum_cath)
            natural_value = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.sum_nat)
            print(catheter_value.text)
            print(catheter_value.text == (cath + ' ml'))  # & natural_value.text == (nat+' ml'))
            if catheter_value.text == (cath + ' ml'):
                print("verify_day_summary_void_cath_entry : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_day_summary_void_cath_entry : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry for beverage"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_day_summary_void_cath_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 080
    def verify_day_summary_void_natu_entry(self):
        '''
        This function verify the day summary void natural entry
        :return:
        '''
        print(" Execution Started : verify_day_summary_void_natu_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4581"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            cath = '4'
            nat = '5'
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys(cath)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys(nat)
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            catheter_value = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.sum_cath)
            natural_value = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.sum_nat)
            print(catheter_value.text)
            print(catheter_value.text == (cath + ' ml'))  # & natural_value.text == (nat+' ml'))
            if catheter_value.text == (cath + ' ml'):
                print("verify_day_summary_void_natu_entry : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_day_summary_void_natu_entry : FAIL")
                status = FAIL
                status_reason = "Not able to verify day summary void natural entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_day_summary_void_natu_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 081
    def verify_me_plus_phone_number(self):
        '''
        This function verify the me plus phone number
        :return:
        '''
        print(" Execution Started : verify_me_plus_phone_number")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5086"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.me_plus).click()
            time.sleep(2)
            mobile_number = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.meplus_mobileno)
            print(mobile_number)
            if mobile_number.is_displayed():
                print("verify_me_plus_phone_number : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_me_plus_phone_number : FAIL")
                status = FAIL
                status_reason = "Not able to me plus phone number"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_me_plus_phone_number ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 082
    def verify_me_plus_email(self):
        '''
        This function verify the me plus email
        :return:
        '''
        print(" Execution Started : verify_me_plus_email")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5087"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.me_plus).click()
            time.sleep(2)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(5)
            email_number = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.meplus_email).is_displayed()
            if email_number:
                print("verify_me_plus_email : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_me_plus_email : FAIL")
                status = FAIL
                status_reason = "Not able to verify me plus email"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_me_plus_email ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 083
    def verify_me_plus_date_time(self):
        '''
        This function verify the me plus date time
        :return:
        '''
        print(" Execution Started : verify_me_plus_date_time")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5088"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.me_plus).click()
            time.sleep(2)
            time_meplus = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.meplus_timings)
            if time_meplus.is_displayed():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to verify me plus date time"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_me_plus_date_time ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_me_plus_phone_number_call(self):
        '''
        This function verify the me plus date time
        :return:
        '''
        print(" Execution Started : verify_me_plus_phone_number_call")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4703"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.me_plus).click()
            time.sleep(2)
            time_meplus = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.meplus_phn_call)
            if time_meplus.is_displayed():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to verify me plus date time"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_me_plus_phone_number_call ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_me_plus_email_send(self):
        '''
        This function verify the me plus email
        :return:
        '''
        print(" Execution Started : verify_me_plus_email_send")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4704"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.me_plus).click()
            time.sleep(2)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(5)
            email_number = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.meplus_email_send).is_displayed()
            if email_number:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to verify me plus email"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_me_plus_email_send ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 084
    def verify_me_plus_text1(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_record_entry_for_beverage_random_future")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5097"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.me_plus).click()
            time.sleep(2)
            text_meplus = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.meplus_text1)
            if text_meplus.is_displayed():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to verify me plus text in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_me_plus_text1 ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 085
    def verify_me_plus_text2(self):
        '''
        This function verify the me plus text
        :return:
        '''
        print(" Execution Started : verify_me_plus_text2")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5099"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.me_plus).click()
            time.sleep(2)
            text_meplus = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.meplus_text2)
            if text_meplus.is_displayed():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to verify me plus text"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_me_plus_text2 ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 086
    def verify_me_plus_logo(self):
        '''
        This function verify the me plus logo in menu
        :return:
        '''
        print(" Execution Started : verify_me_plus_logo")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5098"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.me_plus).click()
            time.sleep(2)
            logo = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.meplus_menu_convatec).is_displayed()
            if logo:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to verify me plus logo in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_me_plus_logo ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 087

    def verify_product_info_tab_menu(self):
        '''
        This function verify the product info tab in menu screen
        :return:
        '''
        print(" Execution Started : verify_product_info_tab_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5682"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            product_info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                               Ios_franklin_Constants.product_info_menu).is_displayed()
            if product_info:
                print("verify_product_info_tab_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_product_info_tab_menu : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry for beverage"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_product_info_tab_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 088

    def verify_FAQs_tab_menu(self):
        '''
        This function verify the FAQs tab in menu
        :return:
        '''
        print(" Execution Started : verify_FAQs_tab_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5683"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            faq_tab = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).is_displayed()
            if faq_tab:
                print("verify_FAQs_tab_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_FAQs_tab_menu : FAIL")
                status = FAIL
                status_reason = "Not able to verify faq's tab in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_FAQs_tab_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 089
    def verify_How_to_use_tab_menu(self):
        '''
        This function verify the quick links tab in menu screen
        :return:
        '''
        print(" Execution Started : verify_How_to_use_tab_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5684"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.IOS_PREDICATE,
                                              Ios_franklin_Constants.how_to_use).is_displayed()
            if use:
                print("verify_How_to_use_tab_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_How_to_use_tab_menu : FAIL")
                status = FAIL
                status_reason = "Not able to verify quick links  tab in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_How_to_use_tab_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 90
    def verify_Privacy_Policy_tab_menu(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_Privacy_Policy_tab_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5685"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            menu_policy = driver.find_element(AppiumBy.IOS_PREDICATE,
                                              Ios_franklin_Constants.privacy_policy_menu).is_displayed()
            if menu_policy:
                print("verify_Privacy_Policy_tab_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_Privacy_Policy_tab_menu : FAIL")
                status = FAIL
                status_reason = "Not able to verify policy tab in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Privacy_Policy_tab_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 91
    def verify_withdraw_consent_tab_menu(self):
        '''
        This function verify the withdraw consent tab in menu
        :return:
        '''
        print(" Execution Started : verify_withdraw_consent_tab_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5686"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            menu_withdraw = driver.find_element(AppiumBy.IOS_PREDICATE,
                                                Ios_franklin_Constants.withdraw_consent_menu).is_displayed()
            if menu_withdraw:
                print("verify_withdraw_consent_tab_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_withdraw_consent_tab_menu : FAIL")
                status = FAIL
                status_reason = "Not able to verify withdraw consent tab in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_withdraw_consent_tab_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 92
    def verify_goal_tab_menu(self):
        '''
        This function verify the goal tab in menu
        :return:
        '''
        print(" Execution Started : verify_goal_tab_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4705"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).is_displayed()
            if goal_info:
                print("verify_goal_tab_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_goal_tab_menu : FAIL")
                status = FAIL
                status_reason = "Not able to verify goal tab in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_goal_tab_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 93
    def verify_email_menu(self):
        '''
        This function verify the email in menu
        :return:
        '''
        print(" Execution Started : verify_email_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5687"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            email_menu_disp = driver.find_element(AppiumBy.IOS_PREDICATE,
                                                  Ios_franklin_Constants.email_menu).is_displayed()
            if email_menu_disp:
                print("verify_email_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_email_menu : FAIL")
                status = FAIL
                status_reason = "Not able to verify email in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_email_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 94
    def verify_phone_menu(self):
        '''
        This function verify the phone number in menu
        :return:
        '''
        print(" Execution Started : verify_phone_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5688"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(5)
            phone_number_info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                                    Ios_franklin_Constants.phone_menu).is_displayed()
            if phone_number_info:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to verify phone number in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_phone_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 95
    def verify_logout_menu(self):
        '''
        This function verify the logout menu
        :return:
        '''
        print(" Execution Started : verify_logout_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5499"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            time.sleep(10)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(5)
            logout_menu_info = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                                   Ios_franklin_Constants.logout_menu_classchain).is_displayed()
            if logout_menu_info:
                print("verify_logout_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_logout_menu : FAIL")
                status = FAIL
                status_reason = "Not able to verify logout in menu screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_logout_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 96
    def verify_logout_app(self):
        '''
        This function verify the logout from franklin application
        :return:
        '''
        print(" Execution Started : verify_logout_app")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5499"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(2)
            product_info = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                               Ios_franklin_Constants.logout_menu_classchain).is_displayed()
            if product_info:
                print("verify_logout_app : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_logout_app : FAIL")
                status = FAIL
                status_reason = "Not able to logout from the application"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_logout_app ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 97
    def verify_username_menu(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_username_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5680"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).is_displayed()
            if username:
                print("verify_username_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_username_menu : FAIL")
                status = FAIL
                status_reason = "Not able to verify username in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_username_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 98

    def verify_user_email_menu(self):
        '''
        This function verify the user email in menu
        :return:
        '''
        print(" Execution Started : verify_user_email_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5681"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            useremail = driver.find_element(AppiumBy.IOS_PREDICATE,
                                            Ios_franklin_Constants.username_menu).is_displayed()
            if useremail:
                print("verify_user_email_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_user_email_menu : FAIL")
                status = FAIL
                status_reason = "Not able to verify user email in menu screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_user_email_menu ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 99

    def verify_navigates_userprofile_menu(self):
        '''
        This function verify the navigate user profile to menu
        :return:
        '''
        print(" Execution Started : verify_navigates_userprofile_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,Ios_franklin_Constants.meplus_userprofile_check).is_displayed()
            if username:
                print("verify_navigates_userprofile_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_navigates_userprofile_menu : FAIL")
                status = FAIL
                status_reason = "Not able to navigate user profile to menu screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_navigates_userprofile_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 100

    def verify_first_name_profile(self):
        '''
        This function verify the first name in user profile in menu
        :return:
        '''
        print(" Execution Started : verify_first_name_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7909"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.menu_userprofile_firstname).is_displayed()
            if username:
                print("verify_first_name_profile : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_first_name_profile : FAIL")
                status = FAIL
                status_reason = "Not able to verify first name in user profile in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_first_name_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 101

    def verify_last_name_profile(self):
        '''
        This function verify the last name in user profile in menu
        :return:
        '''
        print(" Execution Started : verify_last_name_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7910"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            lastname = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.menu_userprofile_secondname).is_displayed()
            if lastname:
                print("verify_last_name_profile : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_last_name_profile : FAIL")
                status = FAIL
                status_reason = "Not able to verify last name in user profile in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_last_name_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 102

    def verify_email_profile(self):
        '''
        This function verify the email in user profile in menu screen
        :return:
        '''
        print(" Execution Started : verify_email_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5689"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.menu_userprofile_email).is_displayed()
            if username:
                print("verify_email_profile : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_email_profile : FAIL")
                status = FAIL
                status_reason = "Not able to verify email in user profile menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_email_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 103
    def verify_contact_profile(self):
        '''
        This function verify the contact in user profile menu
        :return:
        '''
        print(" Execution Started : verify_contact_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5731"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(3)
            username_contactnumber = driver.find_element(AppiumBy.IOS_PREDICATE,Ios_franklin_Constants.menu_userprofile_contactnumber).is_displayed()
            if username_contactnumber:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to check contact profile in user profile menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_contact_profile ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 104

    def verify_age_profile(self):
        '''
        This function verify the age profile in menu
        :return:
        '''
        print(" Execution Started : verify_age_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.menu_userprofile_agerange).is_displayed()
            if username:
                print("verify_age_profile : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_age_profile : FAIL")
                status = FAIL
                status_reason = "Not able to verify age in profile menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_age_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 105

    def verify_gender_profile(self):
        '''
        This function verify the gender profile in menu
        :return:
        '''
        print(" Execution Started : verify_gender_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            username_gender = driver.find_element(AppiumBy.IOS_PREDICATE,
                                                  Ios_franklin_Constants.menu_userprofile_gender).is_displayed()
            if username_gender:
                print("verify_gender_profile : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_gender_profile : FAIL")
                status = FAIL
                status_reason = "Not able to verify gender profile in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_gender_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 106

    def verify_password_profile(self):
        '''
        This function verify the password in profile in menu
        :return:
        '''
        print(" Execution Started : verify_password_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7920"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.menu_userprofile_password).is_displayed()
            if username:
                print("verify_password_profile : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_password_profile : FAIL")
                status = FAIL
                status_reason = "Not able to verify password profile in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_password_profile ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_password_filed_user_profile(self):
        '''
        This function verify the password in profile in menu
        :return:
        '''
        print(" Execution Started : verify_password_filed_user_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7921"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            time.sleep(10)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(5)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.password_field_profile).is_displayed()
            if username:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to verify password profile in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            
            print(az_id, "verify_password_filed_user_profile ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 107

    def verify_update_password_profile(self):
        '''
        This function verify the password update in user profile in menu
        :return:
        '''
        print(" Execution Started : verify_update_password_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7922"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            update_password = driver.find_element(AppiumBy.IOS_PREDICATE,
                                                  Ios_franklin_Constants.menu_userprofile_update).is_displayed()
            if update_password:
                print("verify_update_password_profile : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_update_password_profile : FAIL")
                status = FAIL
                status_reason = "Not able to verify update in password menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_update_password_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 108
    def verify_delete_profile(self):
        '''
        This function verify the DELETEPROFILE in menu
        :return:
        '''
        print(" Execution Started : verify_delete_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            delete_profile = driver.find_element(AppiumBy.IOS_PREDICATE,
                                                 Ios_franklin_Constants.menu_userprofile_delete).is_displayed()
            if delete_profile:
                print("verify_delete_profile : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_delete_profile : FAIL")
                status = FAIL
                status_reason = "Not able to verify delete profile in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_delete_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_delete_week_profile(self):
        '''
        This function verify the DELETEPROFILE in menu
        :return:
        '''
        print(" Execution Started : verify_delete_week_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            delete_profile = driver.find_element(AppiumBy.IOS_PREDICATE,
                                                 Ios_franklin_Constants.menu_userprofile_delete).is_displayed()
            if delete_profile:
                print("verify_delete_week_profile : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_delete_week_profile : FAIL")
                status = FAIL
                status_reason = "Not able to verify delete profile in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_delete_week_profile ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_delete_custom_profile(self):
        '''
        This function verify the DELETEPROFILE in menu
        :return:
        '''
        print(" Execution Started : verify_delete_custom_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(3)
            delete_profile = driver.find_element(AppiumBy.IOS_PREDICATE,
                                                 Ios_franklin_Constants.menu_userprofile_delete).is_displayed()
            if delete_profile:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to verify delete profile in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_delete_custom_profile ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_delete_month_profile(self):
        '''
        This function verify the DELETEPROFILE in menu
        :return:
        '''
        print(" Execution Started : verify_delete_month_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            delete_profile = driver.find_element(AppiumBy.IOS_PREDICATE,
                                                 Ios_franklin_Constants.menu_userprofile_delete).is_displayed()
            if delete_profile:
                print("verify_delete_month_profile : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_delete_month_profile : FAIL")
                status = FAIL
                status_reason = "Not able to verify delete profile in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_delete_month_profile ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 109
    def verify_edit_profile(self):
        '''
        This function verify the the edit profile in menu
        :return:
        '''
        print(" Execution Started : verify_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5975"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.menu_userprofile_edit).is_displayed()
            if username:
                print("verify_edit_profile : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_edit_profile : FAIL")
                status = FAIL
                status_reason = "not able to find edit in profile in Menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edit_week_profile(self):
        '''
        This function verify the the edit profile in menu
        :return:
        '''
        print(" Execution Started : verify_edit_week_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.menu_userprofile_edit).is_displayed()
            if username:
                print("verify_edit_week_profile : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_edit_week_profile : FAIL")
                status = FAIL
                status_reason = "not able to find edit in profile in Menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edit_week_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edit_month_profile(self):
        '''
        This function verify the the edit profile in menu
        :return:
        '''
        print(" Execution Started : verify_edit_month_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.menu_userprofile_edit).is_displayed()
            if username:
                print("verify_edit_month_profile : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_edit_month_profile : FAIL")
                status = FAIL
                status_reason = "not able to find edit in profile in Menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edit_month_profile ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_edit_custom_profile(self):
        '''
        This function verify the the edit profile in menu
        :return:
        '''
        print(" Execution Started : verify_edit_custom_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.menu_userprofile_edit).is_displayed()
            if username:
                print("verify_edit_custom_profile : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_edit_custom_profile : FAIL")
                status = FAIL
                status_reason = "not able to find edit in profile in Menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edit_custom_profile ", status, testcase_execution_time)
        return az_id, status, status_reason
    # 110

    def verify_navigate_profile_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_navigate_profile_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_back).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).is_displayed()
            if username:
                print("verify_navigate_profile_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_navigate_profile_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_navigate_profile_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 111

    def verify_record_entry_leak_current(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_record_entry_leak_current")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6012"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            save = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.recordentry_1).is_displayed()
            if save:
                print("verify_record_entry_leak_current : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_record_entry_leak_current : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_leak_current ", status, testcase_execution_time)
        return az_id, status, status_reason


    ############################## 4Mar
    # 112
    def verify_record_entry_leak_previous(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_record_entry_leak_previous")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6023"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            date = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today)
            time.sleep(1)
            print("today date")
            print(date.text)
            date.click()
            previous_date = (datetime.datetime.now() - datetime.timedelta(1)).strftime("%B %d %Y")
            print(previous_date)
            dat = previous_date.split(" ")[1]
            print(dat)
            if dat[0] == "0":
                dat = dat[1:]
                print(dat)
            dateq = driver.find_element("xpath", f'//XCUIElementTypeStaticText[@name="{dat}"]')
            print(dateq.text)
            dateq.click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save_menu).click()
            time.sleep(2)
            save_ok = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok)
            if save_ok.click():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_leak_previous ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 113
    def verify_record_entry_leak_future(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_record_entry_leak_future")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6017"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            date=driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today).is_displayed()
            if date:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_leak_future ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 114
    def verify_record_entry_for_void_catheter_previous(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_record_entry_for_void_catheter_previous")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(1)
            date = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today)
            time.sleep(1)
            print(date.text)
            date.click()
            previous_date = (datetime.datetime.now() - datetime.timedelta(1)).strftime("%B %d %Y")
            print(previous_date, "previous date")
            dat = previous_date.split(" ")[1]
            print(dat, "date")
            if dat[0] == "0":
                dat = dat[1:]
                print(dat)
            dateq = driver.find_element("xpath", f'//XCUIElementTypeStaticText[@name="{dat}"]')
            print(dateq.text)
            dateq.click()
            print(dateq.text)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('30')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('40')
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(4)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.daysummary_back).click()
            time.sleep(10)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.data_content).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_for_void_catheter_previous ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 115

    def verify_record_entry_for_void_natural_previous(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_record_entry_for_void_natural_previous")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(1)
            date = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today)
            time.sleep(1)
            print(date.text)
            date.click()
            previous_date = (datetime.datetime.now() - datetime.timedelta(1)).strftime("%B %d %Y")
            print(previous_date, "date ::")
            dat = previous_date.split(" ")[1]
            print(dat, "Date")
            if dat[0] == "0":
                dat = dat[1:]
                print("void natural previous date ::", dat)
            dateq = driver.find_element("xpath", f'//XCUIElementTypeStaticText[@name="{dat}"]')
            print(dateq.text)
            dateq.click()
            print(dateq.text)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('30')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('40')
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(4)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.daysummary_back).click()
            time.sleep(10)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.data_content).is_displayed()
            if goal:
                print("verify_record_entry_for_void_natural_previous : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_record_entry_for_void_natural_previous : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_for_void_natural_previous ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 116
    def verify_record_entry_for_beverage_previous(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_record_entry_for_beverage_previous")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(1)
            date = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today)
            time.sleep(1)
            print(date.text)
            date.click()
            previous_date = (datetime.datetime.now() - datetime.timedelta(1)).strftime("%B %d %Y")
            print("beverage previous date ::", previous_date)
            dat = previous_date.split(" ")[1]
            print(dat, "Date ::")
            if dat[0] == "0":
                dat = dat[1:]
                print("printing date ::", dat)
            dateq = driver.find_element("xpath", f'//XCUIElementTypeStaticText[@name="{dat}"]')
            print(dateq.text)
            dateq.click()
            print(dateq.text)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('30')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('40')
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(4)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.daysummary_back).click()
            time.sleep(10)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.data_content).is_displayed()
            if goal:
                print("verify_record_entry_for_beverage_previous : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_record_entry_for_beverage_previous : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_for_beverage_previous ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 117
    def verify_record_entry_for_beverage_random_previous(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_record_entry_for_beverage_random_previous")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(1)
            date = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today)
            time.sleep(1)
            print(date.text)
            date.click()
            previous_date = (datetime.datetime.now() - datetime.timedelta(1)).strftime("%B %d %Y")
            print("random previous date ::", previous_date)
            dat = previous_date.split(" ")[1]
            print("previous date ::", dat)
            if dat[0] == "0":
                dat = dat[1:]
                print("Date print ::", dat)
            dateq = driver.find_element("xpath", f'//XCUIElementTypeStaticText[@name="{dat}"]')
            print(dateq.text)
            dateq.click()
            print(dateq.text)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('30')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('40')
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(4)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.daysummary_back).click()
            time.sleep(10)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.data_content).is_displayed()
            if goal:
                print("verify_record_entry_for_beverage_random_previous : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_record_entry_for_beverage_random_previous : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_for_beverage_random_previous ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 118
    def verify_record_entery_summary_natural_value_edit(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_record_entery_summary_natural_value_edit")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3390"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('3')
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('4')
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_first_select).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_first_select_edit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_first_select_edit_nat).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_first_select_edit_nat).clear()
            time.sleep(2)
            name_sendKeys = '6'
            print(name_sendKeys)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                Ios_franklin_Constants.summary_first_select_edit_nat).send_keys(name_sendKeys)
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                Ios_franklin_Constants.summary_first_select_edit_comment).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE,
                                Ios_franklin_Constants.summary_first_select_edit_comment_save_changes).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            nat_inml = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_nat_ml).text
            if name_sendKeys == nat_inml:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entery_summary_natural_value_edit ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 119
    def verify_void_catheter_value_edit(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_void_catheter_value_edit")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4811"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_cat_select_select).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_first_select_edit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_cat_select_edit_cat).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_cat_select_edit_cat).clear()
            time.sleep(2)
            name_sendKeys = '4'
            print(name_sendKeys)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_cat_select_edit_cat).send_keys(
                name_sendKeys)
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                Ios_franklin_Constants.summary_first_select_edit_comment).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE,
                                Ios_franklin_Constants.summary_first_select_edit_comment_save_changes).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            nat_inml = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                           Ios_franklin_Constants.summary_cat_select_select).text
            print('nat in ml ::', nat_inml)
            if name_sendKeys == nat_inml:
                print("verify_void_catheter_value_edit : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_void_catheter_value_edit : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_void_catheter_value_edit ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 120
    def verify_record_entery_urine_void_delete_button(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_record_entery_urine_void_delete_button")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_cat_select_select).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.summary_edit_delete).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "unable to display delete button for urine entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entery_urine_void_delete_button ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 121
    def verify_record_entery_urine_void_date(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_record_entery_urine_void_date")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3390"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_cat_select_select).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.summary_edit_date).is_displayed()
            if goal:
                print("verify_record_entery_urine_void_date : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_record_entery_urine_void_date : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entery_urine_void_date ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 122

    def verify_void_edit_volume_catheter(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_void_edit_volume_catheter")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4811"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_cat_select_select).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.summary_edit_void_cath).is_displayed()
            if goal:
                print("verify_void_edit_volume_catheter : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_void_edit_volume_catheter : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_void_edit_volume_catheter ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 123

    def verify_void_edit_volume_natural(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_void_edit_volume_natural")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4811"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_cat_select_select).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.summary_edit_void_nat).is_displayed()
            if goal:
                print("verify_void_edit_volume_natural : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_void_edit_volume_natural : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_void_edit_volume_natural ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 124

    def verify_void_edit_volume_commets(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_void_edit_volume_commets")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_cat_select_select).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.summary_edit_void_comments).is_displayed()
            if goal:
                print("verify_void_edit_volume_commets : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_void_edit_volume_commets : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_void_edit_volume_commets ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 125

    def verify_void_edit_volume_Date_Time(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_void_edit_volume_Date_Time")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3392"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_cat_select_select).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.summary_edit_Date_Time).is_displayed()
            if goal:
                print("verify_void_edit_volume_Date_Time : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_void_edit_volume_Date_Time : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_void_edit_volume_Date_Time ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 126

    def verify_void_edit_check_edit(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_void_edit_check_edit")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_cat_select_select).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.summary_first_select_edit).is_displayed()
            if goal:
                print("verify_void_edit_check_edit : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_void_edit_check_edit : FAIL")
                status = FAIL
                status_reason = "unable to edit"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_void_edit_check_edit ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 127

    def verify_void_edit_natural_previous(self):
        '''
        This function verify the edit the natural value
        :return:
        '''
        print(" Execution Started : verify_void_edit_natural_previous")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            date_today = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_date_today)
            print(date_today.text)
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.daysummary_back).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_first_select).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_first_select_edit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_first_select_edit_nat).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_first_select_edit_nat).clear()
            time.sleep(2)
            name_sendKeys = '6'
            print(name_sendKeys)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                Ios_franklin_Constants.summary_first_select_edit_nat).send_keys(
                name_sendKeys)
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                Ios_franklin_Constants.summary_first_select_edit_comment).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE,
                                Ios_franklin_Constants.summary_first_select_edit_comment_save_changes).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.daysummary_back).click()
            time.sleep(2)
            date_previous = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                                Ios_franklin_Constants.summary_edit_date_today)
            print(date_previous.text)
            nat_inml = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_nat_ml).text
            print(nat_inml)
            if name_sendKeys + ' ml' == nat_inml:
                print("verify_void_edit_natural_previous : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_void_edit_natural_previous : FAIL")
                status = FAIL
                status_reason = "unable to edit value"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_void_edit_natural_previous ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 128

    def verify_void_edit_catheter_previous(self):
        '''
        This function verify the edit the catheter value
        :return:
        '''
        print(" Execution Started : verify_void_edit_catheter_previous")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            date_today = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_date_today)
            print(date_today.text)
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.daysummary_back).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_cat_select_select).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_first_select_edit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_cat_select_edit_cat).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_cat_select_edit_cat).clear()
            time.sleep(2)
            name_sendKeys = '4'
            print(name_sendKeys)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_cat_select_edit_cat).send_keys(
                name_sendKeys)
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                Ios_franklin_Constants.summary_first_select_edit_comment).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE,
                                Ios_franklin_Constants.summary_first_select_edit_comment_save_changes).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.daysummary_back).click()
            time.sleep(2)
            date_previous = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                                Ios_franklin_Constants.summary_edit_date_today)
            print(date_previous.text)
            nat_inml = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                           Ios_franklin_Constants.summary_cat_select_select).text
            print('nat in ml ::', nat_inml)
            if name_sendKeys  == nat_inml:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "unable to edit cath pprevious"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_void_edit_catheter_previous ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 129
    def verify_beverage_edit_catheter(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_beverage_edit_catheter")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4811"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            current_time_today = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.current_time)
            print(current_time_today.text)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.water).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage_save).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_cat_select_select).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_first_select_edit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.summary_edit_beverage_medium).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE,
                                Ios_franklin_Constants.summary_edit_bavarage_save_change).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            value = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_beverage_check)
            print(value.text)
            if value.is_displayed():
                print("verify_beverage_edit_catheter : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_beverage_edit_catheter : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_edit_catheter ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 130
    def verify_beverage_edit_catheter_previous(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_beverage_edit_catheter_previous")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3389"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            date = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today)
            time.sleep(1)
            print(date.text)
            date.click()
            previous_date = (datetime.datetime.now() - datetime.timedelta(1)).strftime("%B %d %Y")
            print(previous_date)
            dat = previous_date.split(" ")[1]
            print(dat)
            if dat[0] == "0":
                dat = dat[1:]
                print(dat)
            dateq = driver.find_element("xpath", f'//XCUIElementTypeStaticText[@name="{dat}"]')
            print(dateq.text)
            dateq.click()
            print(dateq.text)
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.water).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage_save).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.daysummary_back).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_cat_select_select).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_first_select_edit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.summary_edit_beverage_medium).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE,
                                Ios_franklin_Constants.summary_edit_bavarage_save_change).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            value = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.summary_beverage_check)
            print(value.text)
            if value.is_displayed():
                print("verify_beverage_edit_catheter_previous : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_beverage_edit_catheter_previous : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_edit_catheter_previous ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 131
    def verify_register_yourself_screen(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_register_yourself_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5491"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            register_screen = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself)
            if register_screen.is_displayed():
                print("verify_register_yourself_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_register_yourself_screen : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 132
    def verify_register_yourself(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_register_yourself")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5493"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(1)
            register = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.provide_details)
            if register.is_displayed():
                print("verify_register_yourself : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_register_yourself : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 133
    def verify_provide_text_register(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_provide_text_register")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5719"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(1)
            details = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.provide_details).text
            if details == 'Provide your details':
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_provide_text_register ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 134
    def verify_register_yourself_first_name(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_register_yourself_first_name")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5720"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(1)
            first_name = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.register_first_name).text
            if first_name == 'First Name':
                print("verify_register_yourself_first_name : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_register_yourself_first_name : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_first_name ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 135
    def verify_register_yourself_last_name(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_register_yourself_last_name")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5721"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(1)
            second_name = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.register_second_name).text
            if second_name == 'Last Name':
                print("verify_register_yourself_last_name : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_register_yourself_last_name : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_last_name ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 136
    def verify_register_yourself_mobile_number(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_register_yourself_mobile_number")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5725"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(3)
            mob_number = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.register_mob_number).text
            if mob_number == 'Contact Number':
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_mobile_number ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 137
    def verify_register_yourself_email(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_register_yourself_email")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5727"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(3)
            email = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.register_email).text
            if email == 'Email':
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_email ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 139
    def verify_register_yourself_email_verification(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_register_yourself_email_verification")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5728"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(1)
            email_verif = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                              Ios_franklin_Constants.register_email_verification)
            if email_verif.is_displayed():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_email_verification ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 140
    def verify_register_yourself_firstname(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_register_yourself_firstname")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5720"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(2)
            name = 'John Cena'
            email_verif = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_user_first_name)
            email_verif.clear()
            time.sleep(2)
            email_verif.send_keys(name)
            time.sleep(2)
            cena = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.firstname_sendkeys)
            time.sleep(2)
            if cena.is_displayed():
                print("verify_register_yourself_firstname : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_register_yourself_firstname : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_firstname ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 141
    def verify_register_yourself_secondname(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_register_yourself_secondname")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5721"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(2)
            name = 'Bat'
            email_verif = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_user_second_name)
            email_verif.clear()
            time.sleep(2)
            email_verif.send_keys(name)
            time.sleep(2)
            secon_name = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.lstname_sendkeys)
            time.sleep(2)
            if secon_name.is_displayed():
                print("verify_register_yourself_secondname : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_register_yourself_secondname : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_secondname ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 142

    def verify_register_yourself_Mobilenumber(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_register_yourself_Mobilenumber")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5725"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(2)
            mail_id = 'naveen@yopmail.com'
            email_verif = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_user_email)
            email_verif.clear()
            time.sleep(2)
            email_verif.send_keys(mail_id)
            time.sleep(2)
            mail_id = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.reg_mailid)
            time.sleep(2)
            if mail_id.is_displayed():
                print("verify_register_yourself_Mobilenumber : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_register_yourself_Mobilenumber : FAIL")
                status = FAIL
                status_reason = "leak record entry for current date is not set"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_Mobilenumber ", status, testcase_execution_time)
        return az_id, status, status_reason

    #143

    def verify_forgot_password_text_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_forgot_password_text_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4860"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.loginscreen).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,Ios_franklin_Constants.fogot_text).text
            if output == 'Forgot Password?':
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_forgot_password_text_login ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 144
    def verify_register_yourself_details_provided_text(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_register_yourself_details_provided_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        az_id = "5726"
        time.sleep(6)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(1)
            details = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.provide_details).text
            if details == 'Provide your details':
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_details_provided_text ", status, testcase_execution_time)
        return az_id, status, status_reason

    ##Mar 4
    #145

    def verify_register_yourself_privacypolicy_check(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_register_yourself_privacypolicy_check")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5729"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(4)
            privacy_policy = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register_checkbox1)
            if privacy_policy.is_displayed():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able open privacy policy"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_privacypolicy_check ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 146
    def verify_register_yourself_privacypolicy(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_register_yourself_privacypolicy")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5730"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(4)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register_checkbox1).click()
            time.sleep(2)
            privacy_policy = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register_checkbox1)
            if privacy_policy:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to sclick on privacy policy"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_privacypolicy ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 147
    def verify_register_yourself_Termsandconditions_checkbox(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_register_yourself_Termsandconditions_checkbox")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5729"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(2)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register_checkbox2).click()
            time.sleep(2)
            terms_conditions = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register_checkbox2).is_displayed()
            if terms_conditions:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_Termsandconditions_checkbox ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 148

    def verify_register_yourself_termsandcond(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_register_yourself_termsandcond")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3360"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(1)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_termsandcond).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_terms_cond_accept).click()
            time.sleep(2)
            terms_conditions = driver.find_element(AppiumBy.IOS_PREDICATE,Ios_franklin_Constants.register_termsandcond).is_displayed()
            if terms_conditions:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_termsandcond ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_register_yourself_back_button_termsandcond(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_register_yourself_back_button_termsandcond")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5951"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(3)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_termsandcond).click()
            time.sleep(2)
            terms_conditions = driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.consent_back_button).is_displayed()
            if terms_conditions:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to find terms and conditions"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_back_button_termsandcond ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 149
    def verify_register_yourself_check_privacypolicy(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_register_yourself_check_privacypolicy")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5730"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(1)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register_checkbox1).click()
            time.sleep(2)
            terms_conditions = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_privacy).is_displayed()
            if terms_conditions:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_check_privacypolicy ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 150
    def verify_register_yourself_check_termsandconditions(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_register_yourself_check_termsandconditions")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        az_id = "5730"
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(2)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register_checkbox2).click()
            time.sleep(1)
            terms_conditions = driver.find_element(AppiumBy.IOS_PREDICATE,
                                                   Ios_franklin_Constants.register_termsandcond).is_displayed()
            if terms_conditions:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_check_termsandconditions ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 151
    def verify_register_yourself_termas_cond_navigation(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_register_yourself_termas_cond_navigation")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '3359'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(2)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(2)
            terms_conditions=driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_privacy).is_displayed()
            if terms_conditions:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_termas_cond_navigation ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_register_yourself_check_privacypolicy_navigation(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_register_yourself_check_privacypolicy_navigation")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '1234'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself).click()
            time.sleep(2)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(2)
            terms_conditions=driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_privacy).is_displayed()
            if terms_conditions:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_check_privacypolicy_navigation ", status, testcase_execution_time)
        return az_id, status, status_reason
    #152

    def verify_forgot_password(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        az_id = "5533"
        print(" Execution Started : verify_forgot_password")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.loginscreen).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.login_forgot_PW).click()
            time.sleep(2)
            forgot_PW = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.login_forgot_PW_validation).is_displayed()
            if forgot_PW:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_forgot_password ", status, testcase_execution_time)
        return az_id, status, status_reason
    #153
    def verify_back_arrow_email_confirmation(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_back_arrow_email_confirmation")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5839"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.registration_back).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_back_arrow_email_confirmation ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 154
    def verify_forgot_password_check_email(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_forgot_password_check_email")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5740"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.login_forgot_PW).click()
            time.sleep(2)
            forgot_PW_email = driver.find_element(AppiumBy.IOS_PREDICATE,
                                                  Ios_franklin_Constants.login_forgot_PW_email_send)
            if forgot_PW_email.is_displayed():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_forgot_password_check_email ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_email_verification_screen(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_email_verification_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '5748'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.login_forgot_PW).click()
            time.sleep(2)
            email_id = 'Naveen@yopmail.com'
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_forgot_PW_email_send).send_keys(
                email_id)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE,
                                Ios_franklin_Constants.login_forgot_pw_email_sendbutton).click()
            time.sleep(4)
            forgot_PW_email = driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.password_reset_message)
            if forgot_PW_email.is_displayed():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to check email verification screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_email_verification_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_time_email_verification_screen(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_time_email_verification_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '5749'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.login_forgot_PW).click()
            time.sleep(2)
            email_id = 'Naveen@yopmail.com'
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_forgot_PW_email_send).send_keys(
                email_id)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE,
                                Ios_franklin_Constants.login_forgot_pw_email_sendbutton).click()
            time.sleep(4)
            forgot_PW_email = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                                  Ios_franklin_Constants.password_reset_message)
            if forgot_PW_email.is_displayed():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to check email verification screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_time_email_verification_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 155
    def verify_forgot_password_check_email_field(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_forgot_password_check_email_field")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5741"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:

            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.login_forgot_PW).click()
            time.sleep(2)
            email_id = 'Naveen@yopmail.com'
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_forgot_PW_email_send).send_keys(
                email_id)
            time.sleep(2)
            forgot_PW_email = driver.find_element(AppiumBy.IOS_PREDICATE,
                                                  Ios_franklin_Constants.login_forgot_pw_email_new).is_displayed()
            if forgot_PW_email:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_forgot_password_check_email_field ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_password_link_text_email_confirmation(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_password_link_text_email_confirmation")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5742"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.login_forgot_PW).click()
            time.sleep(2)
            email_id = 'Naveen@yopmail.com'
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_forgot_PW_email_send).send_keys(
                email_id)
            time.sleep(2)
            forgot_PW_email = driver.find_element(AppiumBy.IOS_PREDICATE,
                                                  Ios_franklin_Constants.login_forgot_pw_email_sendbutton).is_displayed()
            if forgot_PW_email:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_password_link_text_email_confirmation ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 156
    def verify_forgot_password_check_send(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_forgot_password_check_send")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5743"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.login_forgot_PW).click()
            time.sleep(2)
            email_id = 'Naveen@yopmail.com'
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_forgot_PW_email_send).send_keys(
                email_id)
            time.sleep(2)
            forgot_PW_email = driver.find_element(AppiumBy.IOS_PREDICATE,
                                                  Ios_franklin_Constants.login_forgot_pw_email_sendbutton).is_displayed()
            if forgot_PW_email:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_forgot_password_check_send ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_send_click_email_confirmation(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_send_click_email_confirmation")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5744"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.login_forgot_PW).click()
            time.sleep(2)
            email_id = 'Naveen@yopmail.com'
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_forgot_PW_email_send).send_keys(
                email_id)
            time.sleep(2)
            forgot_PW_email = driver.find_element(AppiumBy.IOS_PREDICATE,
                                                  Ios_franklin_Constants.login_forgot_pw_email_sendbutton).is_displayed()
            if forgot_PW_email:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_send_click_email_confirmation ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_send_empty_fields(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_send_empty_fields")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5745"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.login_forgot_PW).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_forgot_pw_email_sendbutton).click()
            time.sleep(2)
            error_check = driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.valid_email).is_displayed()
            if error_check:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_send_empty_fields ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_send_invaild_email(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_send_invaild_email")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5746"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.login_forgot_PW).click()
            time.sleep(2)
            email_id = 'Naveen@yopmail'
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_forgot_PW_email_send).send_keys(
                email_id)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_forgot_pw_email_sendbutton).click()
            time.sleep(2)
            error_check = driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.valid_email).is_displayed()
            if error_check:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_send_invaild_email ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_send_valid_registered_email(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_send_valid_registered_email")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3437"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:

            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.login_forgot_PW).click()
            time.sleep(2)
            email_id = 'Naveen@yopmail.com'
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_forgot_PW_email_send).send_keys(
                email_id)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_forgot_pw_email_sendbutton).click()
            time.sleep(2)
            mail = driver.find_element(AppiumBy.IOS_PREDICATE,Ios_franklin_Constants.email_confirm).is_displayed()
            if mail:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_send_valid_registered_email ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 12/3
    #157
    def verify_share_text_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_share_text_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6082'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).is_displayed()
            if share:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_text_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason
    #158
    def verify_share_report_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_share_report_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6090'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.Share_screen)
            if share.is_displayed():
                print("verify_share_report_daysummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_share_report_daysummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_report_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    #159
    def verify_Today_text_in_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_Today_text_in_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id  = '6094'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today)
            if share.is_displayed():
                print("verify_Today_text_in_daysummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_Today_text_in_daysummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Today_text_in_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    #160
    def verify_Week_text_in_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_Week_text_in_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6095'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week)
            if share.is_displayed():
                print("verify_Week_text_in_daysummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_Week_text_in_daysummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Week_text_in_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    #161
    def verify_month_text_in_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_month_text_in_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6096'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month)
            if share.is_displayed():
                print("verify_month_text_in_daysummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_month_text_in_daysummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_month_text_in_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    #162
    def verify_custom_text_in_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_custom_text_in_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6097'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.custom)
            if share.is_displayed():
                print("verify_custom_text_in_daysummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_custom_text_in_daysummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_custom_text_in_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason
    #163
    def verify_share_pdf_confirmation_screen(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_custom_share_option_in_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6098'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(5)
            share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_screen_confirmation)
            if share.is_displayed():
                print("verify_share_pdf_confirmation_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_share_pdf_confirmation_screen : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_pdf_confirmation_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_text_email_verification_screen(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_text_email_verification_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '5751'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.login_forgot_PW).click()
            time.sleep(2)
            email_id = 'Naveen@yopmail.com'
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_forgot_PW_email_send).send_keys(
                email_id)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE,
                                Ios_franklin_Constants.login_forgot_pw_email_sendbutton).click()
            time.sleep(4)
            forgot_PW_email = driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.password_reset_message)
            if forgot_PW_email.is_displayed():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_text_email_verification_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    #164
    def verify_cance_share_from_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_cance_share_from_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6110'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(5)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.sahre_screen_decline)
            if share.is_displayed():
                print("verify_cance_share_from_daysummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_cance_share_from_daysummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_cance_share_from_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason
    # 165
    def verify_forgot_password_check_enteremail(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_forgot_password_check_enteremail")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '5747'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.login_forgot_PW).click()
            time.sleep(2)
            forgot_PW_email = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                                  Ios_franklin_Constants.login_forgot_PW_enter_email)
            if forgot_PW_email.is_displayed():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_forgot_password_check_enteremail ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 166
    def verify_forgot_password_checkinboxmessage(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_forgot_password_checkinboxmessage")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '3366'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.login_forgot_PW).click()
            time.sleep(2)
            email_id = 'Naveen@yopmail.com'
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_forgot_PW_email_send).send_keys(
                email_id)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE,
                                Ios_franklin_Constants.login_forgot_pw_email_sendbutton).click()
            print('email')
            time.sleep(4)
            forgot_PW_email = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                                  Ios_franklin_Constants.login_forgot_PW_check_emailmessage)
            if forgot_PW_email.is_displayed():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_forgot_password_checkinboxmessage ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 167
    def verify_forgot_password_check_resendmessage(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_forgot_password_check_resendmessage")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '5750'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.login_forgot_PW).click()
            time.sleep(2)
            email_id = 'Naveen@yopmail.com'
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_forgot_PW_email_send).send_keys(
                email_id)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE,
                                Ios_franklin_Constants.login_forgot_pw_email_sendbutton).click()
            time.sleep(4)
            forgot_PW_email = driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.password_reset_message)
            if forgot_PW_email.is_displayed():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_forgot_password_check_resendmessage ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 168
    def verify_forgot_password_checking_message(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_forgot_password_checking_message")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '3477'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.login_forgot_PW).click()
            time.sleep(2)
            email_id = 'Naveen@yopmail.com'
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_forgot_PW_email_send).send_keys(
                email_id)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE,
                                Ios_franklin_Constants.login_forgot_pw_email_sendbutton).click()
            time.sleep(4)
            forgot_PW_email = driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.password_reset_message)
            if forgot_PW_email.is_displayed():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_forgot_password_checking_message ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 169
    def verify_forgot_password_checking_resetmessage(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_forgot_password_checking_resetmessage")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3411"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.login_forgot_PW).click()
            time.sleep(2)
            email_id = 'Naveen@yopmail.com'
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_forgot_PW_email_send).send_keys(
                email_id)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE,
                                Ios_franklin_Constants.login_forgot_pw_email_sendbutton).click()
            print('email')
            time.sleep(4)
            forgot_PW_email = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                                  Ios_franklin_Constants.password_reset_message)
            if forgot_PW_email.is_displayed():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_forgot_password_checking_resetmessage ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 19/3/
    #170
    def verify_convatec_logo_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_convatec_logo_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5484"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            output = driver.find_element(AppiumBy.IOS_PREDICATE,Ios_franklin_Constants.convatec_logo_image).is_displayed()
            if output:
                print("verify_convatec_logo_launch : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_convatec_logo_launch : FAIL")
                status = FAIL
                status_reason = "Application not on launch screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_convatec_logo_launch ", status, testcase_execution_time)
        return az_id, status, status_reason

    #171
    def verify_welcome_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_welcome_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5488"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.welcome_logo).is_displayed()
            if output:
                print("verify_welcome_launch : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_welcome_launch : FAIL")
                status = FAIL
                status_reason = "Application not on launch screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_welcome_launch ", status, testcase_execution_time)
        return az_id, status, status_reason
    #172
    def verify_franklin_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_franklin_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5489"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Franklin).is_displayed()
            if output:
                print("verify_franklin_launch : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_franklin_launch : FAIL")
                status = FAIL
                status_reason = "Application not on launch screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_franklin_launch ", status, testcase_execution_time)
        return az_id, status, status_reason

    #173
    def verify_track_text_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_track_text_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5490"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.Track).is_displayed()
            if output:
                print("verify_track_text_launch : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_track_text_launch : FAIL")
                status = FAIL
                status_reason = "Application not on launch screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_franklin_launch ", status, testcase_execution_time)
        return az_id, status, status_reason

    #174
    def verify_register_text_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_register_text_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5491"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Register).is_displayed()
            if output:
                print("verify_register_text_launch : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_register_text_launch : FAIL")
                status = FAIL
                status_reason = "Application not on launch screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_text_launch ", status, testcase_execution_time)
        return az_id, status, status_reason

    #175
    def verify_login_text_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_login_text_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5492"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                         Ios_franklin_Constants.login_button_launch).is_displayed()
            if output:
                print("verify_login_text_launch : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_login_text_launch : FAIL")
                status = FAIL
                status_reason = "Application not on launch screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_login_text_launch ", status, testcase_execution_time)
        return az_id, status, status_reason

    #176
    def verify_version_text_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_version_text_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5495"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                         Ios_franklin_Constants.version_launch).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on launch screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_version_text_launch ", status, testcase_execution_time)
        return az_id, status, status_reason
    #177
    def verify_version_number_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_version_number_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5485"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                         Ios_franklin_Constants.version_launch).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on launch screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_version_text_launch ", status, testcase_execution_time)
        return az_id, status, status_reason

    #178
    def verify_contact_us_text_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_contact_us_text_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5487"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                         Ios_franklin_Constants.contact_us_in_login).is_displayed()
            if output:
                print("verify_contact_us_text_launch : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_contact_us_text_launch : FAIL")
                status = FAIL
                status_reason = "Application not on launch screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_contact_us_text_launch ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_contact_us_text_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_contact_us_text_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.contact_us_email).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on launch screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_contact_us_text_launch ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_contact_us_email_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_contact_us_email_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.contact_us_email).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on launch screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_contact_us_email_launch ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_contact_us_number_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_contact_us_number_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.contact_us_number).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on launch screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_contact_us_number_launch ", status, testcase_execution_time)
        return az_id, status, status_reason
    #179

    def verify_register_click_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_register_click_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            register_screen = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_yourself)
            if register_screen.is_displayed():
                print("verify_register_click_launch : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_register_click_launch : FAIL")
                status = FAIL
                status_reason = "Application not on launch screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_yourself_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    #180
    def verify_login_click_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_login_click_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5494"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                         Ios_franklin_Constants.login_button_launch).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_login_click_launch ", status, testcase_execution_time)
        return az_id, status, status_reason

    #181
    def verify_login_text_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_login_text_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5525"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_PREDICATE,
                                         Ios_franklin_Constants.login_screen_check).is_displayed()
            if output:
                print("verify_login_text_login : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_login_text_login : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_login_text_login ", status, testcase_execution_time)
        return az_id, status, status_reason
    #182
    def verify_email_text_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_email_text_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5529"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                         Ios_franklin_Constants.email_text_login).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_email_text_login ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_version_text_login_email_conf_screen(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_version_text_login_email_conf_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5522"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.Login).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_version_text_login_email_conf_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_version_number_login_email_conf_screen(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_version_number_login_email_conf_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5524"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.Login).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_version_number_login_email_conf_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_contact_us_text_login_email_conf_screen(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_contact_us_text_login_email_conf_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5523"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                         Ios_franklin_Constants.contact_us_in_login).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_contact_us_text_login_email_conf_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    #183
    def verify_email_field_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_email_field_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5526"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_PREDICATE,
                                         Ios_franklin_Constants.login_screen_email).is_displayed()
            if output:
                print("verify_email_field_login : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_email_field_login : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_email_field_login ", status, testcase_execution_time)
        return az_id, status, status_reason
    #184
    def verify_password_text_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_password_text_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5527"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                         Ios_franklin_Constants.password_text_login).is_displayed()
            if output:
                print("verify_password_text_login : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_password_text_login : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_password_text_login ", status, testcase_execution_time)
        return az_id, status, status_reason
    #185
    def verify_password_field_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_password_field_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5527"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_PREDICATE,
                                         Ios_franklin_Constants.login_screen_password).is_displayed()
            if output:
                print("verify_password_field_login : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_password_field_login : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_password_field_login ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_login_click_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_login_click_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5494"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                         Ios_franklin_Constants.login_button_launch).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_login_click_launch ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_share_logs_text_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_share_logs_text_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not displaying share logs text in launch screen"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            print(az_id, "verify_share_logs_text_launch ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_logs_text_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_share_logs_text_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.share_logs_email_field).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to launch the share logs"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            print(az_id, "verify_click_share_logs_text_launch ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_logs_email_text_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_share_logs_email_text_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.share_logs_email_field).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Email text is not displaying in the shared logs"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            print(az_id, "verify_click_share_logs_email_text_launch", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_logs_email_field_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_share_logs_email_field_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.share_logs_email_field).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Email field is not displaying in the shared logs"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)

            print(az_id, "verify_click_share_logs_email_field_launch ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_logs_cancel_button_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_share_logs_cancel_button_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login_cancel_button).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Cancel button is not displaying in the shared logs"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            print(az_id, "verify_click_share_logs_cancel_button_launch", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_logs_cancel_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_share_logs_cancel_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login_cancel_button).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to click on cancel button"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            print(az_id, "verify_click_share_logs_cancel_launch ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_logs_share_logs_button_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_share_logs_share_logs_button_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_share_button_login).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to display share logs button in share logs screen"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            print(az_id, "verify_click_share_logs_share_logs_button_launch ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_logs_error_share_logs_button_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_share_logs_error_share_logs_button_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_share_button_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.share_logs_email_field).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to display error in share logs screen clicking without filling filed"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)

            print(az_id, "verify_click_share_logs_error_share_logs_button_launch ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_success_message_for_share_logs_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_success_message_for_share_logs_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.share_logs_email_field).send_keys('Harini@yopmail.com')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_share_button_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.successful_share_logs).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "success message not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)

            print(az_id, "verify_success_message_for_share_logs_launch ", status, testcase_execution_time)
        return az_id, status, status_reason


    #186
    def verify_login_button_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_login_button_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5531"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_screen_email).send_keys(
                'Setha@yopmail.com')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.submit).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.Login).is_displayed()
            if output:
                print("verify_login_button_login : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_login_button_login : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_login_button_login ", status, testcase_execution_time)
        return az_id, status, status_reason
    #187
    def verify_version_text_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_version_text_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5522"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.Login).is_displayed()
            if output:
                print("verify_version_text_login : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_version_text_login : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_version_text_login ", status, testcase_execution_time)
        return az_id, status, status_reason
    #188
    def verify_contactus_text_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_contactus_text_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5523"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                         Ios_franklin_Constants.contact_us_in_login).is_displayed()
            if output:
                print("verify_contactus_text_login : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_contactus_text_login : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_version_text_login ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_contact_us_text_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_contact_us_text_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.contact_us_email).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on launch screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_contact_us_text_login ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_share_logs_text_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_share_logs_text_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not displaying share logs text"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)

            print(az_id, "verify_share_logs_text_login ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_logs_text_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_share_logs_text_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.share_logs_email_field).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to launch the share logs"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)

            print(az_id, "verify_click_share_logs_text_login ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_logs_email_text_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_share_logs_email_text_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.share_logs_email_field).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Email text is not displaying in the shared logs"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)

            print(az_id, "verify_click_share_logs_email_text_login ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_logs_email_field_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_share_logs_email_field_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.share_logs_email_field).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Email field is not displaying in the shared logs"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)

            print(az_id, "verify_click_share_logs_email_field_login ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_logs_cancel_button_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_share_logs_cancel_button_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login_cancel_button).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Cancel button is not displaying in the shared logs"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)

            print(az_id, "verify_click_share_logs_cancel_button_login ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_logs_cancel_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_share_logs_cancel_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login_cancel_button).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to click on cancel button"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)

            print(az_id, "verify_click_share_logs_cancel_login ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_logs_share_logs_button_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_share_logs_share_logs_button_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_share_button_login).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to display share logs button in share logs screen"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)

            print(az_id, "verify_click_share_logs_share_logs_button_login ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_logs_error_share_logs_button_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_share_logs_error_share_logs_button_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_share_button_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.share_logs_email_field).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to display error in share logs screen clicking without filling filed"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)

            print(az_id, "verify_click_share_logs_error_share_logs_button_login ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_success_message_for_share_logs_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_success_message_for_share_logs_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_login).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.share_logs_email_field).send_keys('Setha@yopmail.com')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_share_button_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.successful_share_logs).is_displayed()
            if output:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "success message not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)

            print(az_id, "verify_success_message_for_share_logs_login ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_contact_us_email_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_contact_us_email_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.contact_us_email).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_contact_us_email_login ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_contact_us_number_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_click_contact_us_number_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.contact_us_in_login).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.contact_us_number).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_contact_us_number_login ", status, testcase_execution_time)
        return az_id, status, status_reason

    #189
    def verify_version_number_login(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_version_number_login")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5524"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_login_click).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.version_login).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_version_number_login ", status, testcase_execution_time)
        return az_id, status, status_reason

    ###############   register back  ##########
    #190
    def verify_get_back_register_launch(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_get_back_register_launch")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5718"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios)
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.registration_back).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_get_back_register_launch ", status, testcase_execution_time)
        return az_id, status, status_reason
    #191
    def verify_first_name_text_register(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_first_name_text_register")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5720"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                         Ios_franklin_Constants.firstname_text).is_displayed()
            if output:
                print("verify_first_name_text_register : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_first_name_text_register : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_first_name_text_register ", status, testcase_execution_time)
        return az_id, status, status_reason
    #192
    def verify_last_name_text_register(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_last_name_text_register")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5721"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.lastname_text).is_displayed()
            if output:
                print("verify_last_name_text_register : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_last_name_text_register : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_first_name_text_register ", status, testcase_execution_time)
        return az_id, status, status_reason
    #193
    def verify_mobile_text_register(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_mobile_text_register")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5725"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.Contact_number).text
            if output == "Contact Number":
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_mobile_text_register ", status, testcase_execution_time)
        return az_id, status, status_reason
    #194
    def verify_mobile_country_code_register(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_mobile_country_code_register")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5727"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                         Ios_franklin_Constants.register_mob_user).is_displayed()
            if output:
                print("verify_mobile_country_code_register : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_mobile_country_code_register : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_mobile_country_code_register ", status, testcase_execution_time)
        return az_id, status, status_reason
    #195
    def verify_email_text_register(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_email_text_register")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5727"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.Email).is_displayed()
            if output:
                print("verify_email_text_register : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_email_text_register : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_email_text_register ", status, testcase_execution_time)
        return az_id, status, status_reason
    #196
    def verify_ver_link_text_register(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_ver_link_text_register")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5728"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                         Ios_franklin_Constants.verification_text).is_displayed()
            if output:
                print("verify_ver_link_text_register : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_ver_link_text_register : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_ver_link_text_register ", status, testcase_execution_time)
        return az_id, status, status_reason

    #197
    def verify_tc1_text_register(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_tc1_text_register")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5729"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register).click()
            time.sleep(2)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(5)
            output = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_privacy).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_tc1_text_register ", status, testcase_execution_time)
        return az_id, status, status_reason
    #198
    def verify_tc2_text_register(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_tc2_text_register")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5730"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register).click()
            time.sleep(2)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(5)
            output = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.register_privacy).is_displayed()
            if output:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_tc2_text_register ", status, testcase_execution_time)
        return az_id, status, status_reason

    #199
    def verify_register_button_default_disable(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_register_button_default_disable")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.launch_screen_ios).is_displayed()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.register).click()
            time.sleep(2)
            output = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                         Ios_franklin_Constants.register_button_details).is_displayed()
            if output:
                print("verify_register_button_default_disable : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_register_button_default_disable : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_register_button_default_disable ", status, testcase_execution_time)
        return az_id, status, status_reason
    #25/3
    # 1
    def verify_share_icon_daysummary(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_share_icon_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        # status_reason = None
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6083"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).is_displayed()
            if share:
                print("verify_share_icon_daysummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_share_icon_daysummary : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_icon_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 2
    def verify_share_icon_weeksummary(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_share_icon_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6085"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(4)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).is_displayed()
            if share:
                print("verify_share_icon_weeksummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_share_icon_weeksummary : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_icon_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 3
    def verify_share_text_weeksummary(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_share_text_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6084"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(4)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(3)
            share = driver.find_element(AppiumBy.IOS_PREDICATE,Ios_franklin_Constants.week_month_share_text).is_displayed()
            if share:
                print("verify_share_text_weeksummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_share_text_weeksummary : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_text_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 4
    def verify_share_text_monthsummary(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_share_text_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6086"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(4)
            share = driver.find_element(AppiumBy.IOS_PREDICATE,Ios_franklin_Constants.week_month_share_text).is_displayed()
            if share:
                print("verify_share_text_monthsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_share_text_monthsummary : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_text_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 5
    def verify_share_icon_monthsummary(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_share_icon_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6087"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(4)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).is_displayed()
            if share:
                print("verify_share_icon_monthsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_share_icon_monthsummary : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_icon_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 6
    def verify_share_icon_customsummary(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_share_icon_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6089"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(4)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).is_displayed()
            if share:
                print("verify_share_icon_customsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_share_icon_customsummary : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_icon_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 7
    def verify_share_text_customsummary(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_share_text_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6088"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(4)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).is_displayed()
            if share:
                print("verify_share_text_customsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_share_text_customsummary : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_text_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 8
    def verify_share_report_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_share_report_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6091'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.Share_screen)
            if share.is_displayed():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_report_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 9
    def verify_share_report_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_share_report_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6092'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.Share_screen)
            if share.is_displayed():
                print("verify_share_report_monthsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_share_report_monthsummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_report_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 10
    def verify_share_report_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_share_report_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6093'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.Share_screen)
            if share.is_displayed():
                print("verify_share_report_customsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_share_report_customsummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_report_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 11
    ########for week test over all texts in week summary

    def verify_Today_text_in_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_Today_text_in_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6098'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today)
            if share.is_displayed():
                print("verify_Today_text_in_weeksummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_Today_text_in_weeksummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Today_text_in_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 12
    def verify_Week_text_in_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_Week_text_in_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6099'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week)
            if share.is_displayed():
                print("verify_Week_text_in_weeksummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_Week_text_in_weeksummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Week_text_in_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 13
    def verify_month_text_in_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_month_text_in_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6010'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month)
            if share.is_displayed():
                print("verify_month_text_in_weeksummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_month_text_in_weeksummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_month_text_in_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 14
    def verify_custom_text_in_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_custom_text_in_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6100'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.custom)
            if share.is_displayed():
                print("verify_custom_text_in_weeksummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_custom_text_in_weeksummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_custom_text_in_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 15
    def verify_custom_icon_in_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_custom_icon_in_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6101'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.custom)
            if share.is_displayed():
                print("verify_custom_icon_in_weeksummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_custom_icon_in_weeksummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_custom_icon_in_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 16
    def verify_Today_text_in_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_Today_text_in_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6102'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(3)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today)
            if share.is_displayed():
                print("verify_Today_text_in_monthsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_Today_text_in_monthsummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Today_text_in_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 17
    def verify_week_text_in_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_week_text_in_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6103'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week)
            if share.is_displayed():
                print("verify_week_text_in_monthsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_week_text_in_monthsummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_week_text_in_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 18
    def verify_month_text_in_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_month_text_in_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6104'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month)
            if share.is_displayed():
                print("verify_month_text_in_monthsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_month_text_in_monthsummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_month_text_in_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 19
    def verify_custom_text_in_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_custom_text_in_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6105'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.custom)
            if share.is_displayed():
                print("verify_custom_text_in_monthsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_custom_text_in_monthsummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_custom_text_in_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 20
    ######custom sharing texts
    def verify_Today_text_in_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_Today_text_in_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6106'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(3)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today)
            if share.is_displayed():
                print("verify_Today_text_in_customsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_Today_text_in_customsummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Today_text_in_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 21
    def verify_week_text_in_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_week_text_in_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6107'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week)
            if share.is_displayed():
                print("verify_week_text_in_customsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_week_text_in_customsummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_week_text_in_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 22
    def verify_month_text_in_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_month_text_in_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6108'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(3)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month)
            if share.is_displayed():
                print("verify_month_text_in_customsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_month_text_in_customsummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_month_text_in_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 23
    def verify_custom_text_in_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_custom_text_in_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6109'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.custom)
            if share.is_displayed():
                print("verify_custom_text_in_customsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_custom_text_in_customsummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_custom_text_in_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 24
    def verify_cance_share_from_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_cance_share_from_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6111'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(5)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.sahre_screen_decline)
            if share.is_displayed():
                print("verify_cance_share_from_monthsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_cance_share_from_monthsummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_cance_share_from_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_menu_text(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_menu_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '4321'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:

            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu)
            if share.is_displayed():
                print("verify_menu_text : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_menu_text : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_menu_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_on_menu_text(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_on_menu_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '123'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:

            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            navigation = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Menu_screen).is_displayed()
            if navigation:
                print("verify_click_on_menu_text : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_click_on_menu_text : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_on_menu_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_menu_icon(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_menu_icon")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '123'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:

            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu)
            if share.is_displayed():
                print("verify_menu_icon : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_menu_icon : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_menu_icon ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 1

    def verify_navigate_symbol_profile_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_navigate_symbol_profile_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5978"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.username_menu).is_displayed()
            if username:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_navigate_symbol_profile_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 2
    def verify_click_on_goal_tab_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_on_goal_tab_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6546"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.goal_screen_menu).is_displayed()
            if goal_info:
                print("verify_click_on_goal_tab_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_click_on_goal_tab_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_on_goal_tab_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 3
    def verify_setgoal_on_goal_tab_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_setgoal_on_goal_tab_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6533"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.goal_units_menu).is_displayed()
            if goal_info:
                print("verify_setgoal_on_goal_tab_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_setgoal_on_goal_tab_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_setgoal_on_goal_tab_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 4
    def verify_setgoal_by_selection_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_setgoal_by_selection_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6544"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.goal_user_input_menu).send_keys('123')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Menu_screen).is_displayed()
            if goal_info:
                print("verify_setgoal_by_selection_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_setgoal_by_selection_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_setgoal_by_selection_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 5
    def verify_setgoal_input_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_setgoal_input_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6545"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.goal_user_input_menu).send_keys(
                '500')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Menu_screen).is_displayed()
            if goal_info:
                print("verify_setgoal_input_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_setgoal_input_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_setgoal_input_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 6
    def verify_setgoal_cancel_text_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_setgoal_cancel_text_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6534"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                            Ios_franklin_Constants.cancel_goal_menu).is_displayed()
            if goal_info:
                print("verify_setgoal_cancel_text_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_setgoal_cancel_text_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_setgoal_cancel_text_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    # 7
    def verify_setgoal_cancel_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_setgoal_cancel_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6543"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.cancel_goal_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Menu_screen).is_displayed()
            if goal_info:
                print("verify_setgoal_cancel_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_setgoal_cancel_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_setgoal_cancel_menu ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_share_option(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_share_option")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6089"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol)
            if share.is_displayed():
                print("verify_share_option : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_share_option : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_option ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_share_option_screen(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_share_option_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6094"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.Share_screen)
            if share.is_displayed():
                print("verify_share_option_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_share_option_screen : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_option_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_Today_share_option_in_screen(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_Today_share_option_in_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6090"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today)
            if share.is_displayed():
                print("verify_Today_share_option_in_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_Today_share_option_in_screen : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Today_share_option_in_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_Week_share_option_in_screen(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_Week_share_option_in_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6091"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week)
            if share.is_displayed():
                print("verify_Week_share_option_in_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_Week_share_option_in_screen : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Week_share_option_in_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_month_share_option_in_screen(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_month_share_option_in_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6092"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month)
            if share.is_displayed():
                print("verify_month_share_option_in_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_month_share_option_in_screen : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_month_share_option_in_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_custom_share_option_in_screen(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_custom_share_option_in_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6093"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.custom)
            if share.is_displayed():
                print("verify_custom_share_option_in_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_custom_share_option_in_screen : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_custom_share_option_in_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_share_pdf_custom_confirmation_screen(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_share_pdf_custom_confirmation_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6101"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(5)
            share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_screen_confirmation)
            if share.is_displayed():
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_pdf_custom_confirmation_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_cancel_share_pdf_confirmation_screen(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_cancel_share_pdf_confirmation_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6110"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(5)
            share = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.sahre_screen_decline)
            if share.is_displayed():
                print("verify_cancel_share_pdf_confirmation_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_cancel_share_pdf_confirmation_screen : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_cancel_share_pdf_confirmation_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    ############27/3
    def verify_day_in_background_share_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_day_in_background_share__daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6114'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(5)
            share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.check)
            if share.is_displayed():
                print("verify_day_in_background_share_daysummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_day_in_background_share_daysummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_day_in_background_share_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_week_in_background_share_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_week_in_background_share_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6118'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week).click()
            time.sleep(5)
            share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.check)
            if share.is_displayed():
                print("verify_week_in_background_share_daysummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_week_in_background_share_daysummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_week_in_background_share_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_month_in_background_share_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_month_in_background_share_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6122'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month).click()
            time.sleep(5)
            share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.check)
            if share.is_displayed():
                print("verify_month_in_background_share_daysummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_month_in_background_share_daysummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_month_in_background_share_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_custom_in_background_share_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_custom_in_background_share__daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6130'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.custom).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(1)
            try:
                share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.check)
                if share.is_displayed():
                    print("verify_custom_in_background_share_daysummary : PASS")
                    status =  PASS
                    status_reason =  TEST_SUCCESSFUL
                else:
                    print("verify_custom_in_background_share_daysummary : FAIL")
                    status = FAIL
                    status_reason = "Not able to set record entry"
            except:
                share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok)
                if share.is_displayed():
                    print("verify_custom_in_background_share_daysummary : PASS")
                    status =  PASS
                    status_reason =  TEST_SUCCESSFUL
                else:
                    print("verify_custom_in_background_share_daysummary : FAIL")
                    status = FAIL
                    status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_custom_in_background_share_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_day_in_background_share_weeksummary(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_day_in_background_share_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6115"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.check).is_displayed()
            if share:
                print("verify_day_in_background_share_weeksummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_day_in_background_share_weeksummary : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_day_in_background_share_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_day_in_background_share_monthsummary(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_day_in_background_share_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6116"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(4)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.check).is_displayed()
            if share:
                print("verify_day_in_background_share_monthsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_day_in_background_share_monthsummary : FAIL")
                status = FAIL
                status_reason = "Application not on login screen"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_day_in_background_share_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_day_in_background_share_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_day_in_background_share_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6117'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(2)
            try:
                share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.check)
                if share.is_displayed():
                    print("verify_day_in_background_share_customsummary : PASS")
                    status =  PASS
                    status_reason =  TEST_SUCCESSFUL
                else:
                    print("verify_day_in_background_share_customsummary : FAIL")
                    status = FAIL
                    status_reason = "Not able to set record entry"
            except:
                share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok)
                if share.is_displayed():
                    print("verify_day_in_background_share_customsummary : PASS")
                    status =  PASS
                    status_reason =  TEST_SUCCESSFUL
                else:
                    print("verify_day_in_background_share_customsummary : FAIL")
                    status = FAIL
                    status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_day_in_background_share_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_week_in_background_share_weeksummary(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_week_in_background_share_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6119"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:

            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(4)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week).click()
            time.sleep(2)
            try:
                share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.check)
                if share.is_displayed():
                    print("verify_week_in_background_share_weeksummary : PASS")
                    status =  PASS
                    status_reason =  TEST_SUCCESSFUL
                else:
                    print("verify_week_in_background_share_weeksummary : FAIL")
                    status = FAIL
                    status_reason = "Not able to set record entry"
            except:
                share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok)
                if share.is_displayed():
                    print("verify_week_in_background_share_weeksummary : PASS")
                    status =  PASS
                    status_reason =  TEST_SUCCESSFUL
                else:
                    print("verify_week_in_background_share_weeksummary : FAIL")
                    status = FAIL
                    status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_week_in_background_share_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_week_in_background_share_monthsummary(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_week_in_background_share_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6120"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:

            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(4)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week).click()
            time.sleep(2)
            try:
                share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.check)
                if share.is_displayed():
                    print("verify_week_in_background_share_monthsummary : PASS")
                    status =  PASS
                    status_reason =  TEST_SUCCESSFUL
                else:
                    print("verify_week_in_background_share_monthsummary : FAIL")
                    status = FAIL
                    status_reason = "Not able to set record entry"
            except:
                share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok)
                if share.is_displayed():
                    print("verify_week_in_background_share_monthsummary : PASS")
                    status =  PASS
                    status_reason =  TEST_SUCCESSFUL
                else:
                    print("verify_week_in_background_share_monthsummary : FAIL")
                    status = FAIL
                    status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_week_in_background_share_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_week_in_background_share_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_week_in_background_share_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6121'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week).click()
            time.sleep(2)
            try:
                share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.check)
                if share.is_displayed():
                    print("verify_week_in_background_share_customsummary : PASS")
                    status =  PASS
                    status_reason =  TEST_SUCCESSFUL
                else:
                    print("verify_week_in_background_share_customsummary : FAIL")
                    status = FAIL
                    status_reason = "Not able to set record entry"
            except:
                share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok)
                if share.is_displayed():
                    print("verify_week_in_background_share_customsummary : PASS")
                    status =  PASS
                    status_reason =  TEST_SUCCESSFUL
                else:
                    print("verify_week_in_background_share_customsummary : FAIL")
                    status = FAIL
                    status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_week_in_background_share_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_month_in_background_share_weeksummary(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_month_in_background_share_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6123"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:

            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(4)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month).click()
            time.sleep(2)
            try:
                share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.check)
                if share.is_displayed():
                    print("verify_month_in_background_share_weeksummary : PASS")
                    status =  PASS
                    status_reason =  TEST_SUCCESSFUL
                else:
                    print("verify_month_in_background_share_weeksummary : FAIL")
                    status = FAIL
                    status_reason = "Not able to set record entry"
            except:
                share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok)
                if share.is_displayed():
                    print("verify_month_in_background_share_weeksummary : PASS")
                    status =  PASS
                    status_reason =  TEST_SUCCESSFUL
                else:
                    print("verify_month_in_background_share_weeksummary : FAIL")
                    status = FAIL
                    status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_month_in_background_share_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_month_in_background_share_monthsummary(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_month_in_background_share_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6124"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:

            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(4)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month).click()
            time.sleep(2)
            try:
                share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.check)
                if share.is_displayed():
                    print("verify_month_in_background_share_monthsummary : PASS")
                    status =  PASS
                    status_reason =  TEST_SUCCESSFUL
                else:
                    print("verify_month_in_background_share_monthsummary : FAIL")
                    status = FAIL
                    status_reason = "Not able to set record entry"
            except:
                share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok)
                if share.is_displayed():
                    print("verify_month_in_background_share_monthsummary : PASS")
                    status =  PASS
                    status_reason =  TEST_SUCCESSFUL
                else:
                    print("verify_month_in_background_share_monthsummary : FAIL")
                    status = FAIL
                    status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_month_in_background_share_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_month_in_background_share_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_month_in_background_share_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6125'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month).click()
            time.sleep(2)
            try:
                share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.check)
                if share.is_displayed():
                    print("verify_month_in_background_share_customsummary : PASS")
                    status =  PASS
                    status_reason =  TEST_SUCCESSFUL
                else:
                    print("verify_month_in_background_share_customsummary : FAIL")
                    status = FAIL
                    status_reason = "Not able to set record entry"
            except:
                share = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok)
                if share.is_displayed():
                    print("verify_month_in_background_share_customsummary : PASS")
                    status =  PASS
                    status_reason =  TEST_SUCCESSFUL
                else:
                    print("verify_month_in_background_share_customsummary : FAIL")
                    status = FAIL
                    status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_month_in_background_share_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_custom_in_background_share_weeksummary(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_custom_in_background_share_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6131"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(4)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.custom).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_ranges)
            if share.is_displayed():
                print("verify_custom_in_background_share_weeksummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_custom_in_background_share_weeksummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"

        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_custom_in_background_share_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_custom_in_background_share_monthsummary(self):
        '''
        This function verify the record entry for current leak value
        :return:
        '''
        print(" Execution Started : verify_custom_in_background_share_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6132"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(4)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.custom).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_ranges)
            if share.is_displayed():
                print("verify_custom_in_background_share_monthsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_custom_in_background_share_monthsummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_custom_in_background_share_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_custom_in_background_share_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_custom_in_background_share_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '6133'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.custom).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_ranges)
            if share.is_displayed():
                print("verify_custom_in_background_share_customsummary : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_custom_in_background_share_customsummary : FAIL")
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_month_in_background_share_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason
#added 3/4
    #219

    def verify_menu_in_menuscreen(self):
        '''
        This function verify the menu dashboard
        :return:
        '''
        print(" Execution Started : verify_menu_in_menuscreen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = '5679'
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(8)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Menu_screen).is_displayed()
            if goal:
                print("verify_menu_in_menuscreen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_menu_in_menuscreen : FAIL")
                status = FAIL
                status_reason = "Application not display menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_menu_in_menuscreen ", status, testcase_execution_time)
        return az_id, status, status_reason

    #220
    def verify_phone_icon_menu(self):
        '''
        This function verify the phone number in menu
        :return:
        '''
        print(" Execution Started : verify_phone_icon_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5690"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(3)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(5)
            phone_number_info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                                    Ios_franklin_Constants.phone_menu).is_displayed()
            if phone_number_info:
                print("verify_phone_icon_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_phone_icon_menu : FAIL")
                status = FAIL
                status_reason = "Not able to verify phone number in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_phone_icon_menu ", status, testcase_execution_time)
        return az_id, status, status_reason

    #221
    def verify_setgoal_default_set_from_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_setgoal_default_set_from_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6536"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                            Ios_franklin_Constants.default_set_menu).is_displayed()
            if goal_info:
                print("verify_setgoal_default_set_from_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_setgoal_default_set_from_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_setgoal_default_set_from_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_enable_set_by_selection_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_enable_set_by_selection_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6538"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.goal_user_input_menu).send_keys('499')
            time.sleep(2)
            set = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).is_displayed()
            if set:
                print("verify_enable_set_by_selection_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_enable_set_by_selection_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_enable_set_by_selection_menu ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_enable_set_by_input_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_enable_set_by_input_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6537"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.goal_user_input_menu).send_keys(
                '500')
            time.sleep(2)
            set = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).is_displayed()
            if set:
                print("verify_enable_set_by_input_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_enable_set_by_input_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_enable_set_by_input_menu ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 1/4
    def verify_oz_equivalent_ml_set_by_input_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_oz_equivalent_ml_set_by_input_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6539"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            set = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.goal_units_menu).is_displayed()
            if set:
                print("verify_oz_equivalent_ml_set_by_input_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_oz_equivalent_ml_set_by_input_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_oz_equivalent_ml_set_by_input_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_oz_equivalent_zero_ml_set_by_input_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_oz_equivalent_zero_ml_set_by_input_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6540"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            set = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_setgoal_ml).is_displayed()
            if set:
                print("verify_oz_equivalent_zero_ml_set_by_input_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_oz_equivalent_zero_ml_set_by_input_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_oz_equivalent_zero_ml_set_by_input_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_setdrinkinggoal_from_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_setdrinkinggoal_from_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6541"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.goal_screen_menu).is_displayed()
            if goal_info:
                print("verify_setdrinkinggoal_from_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_setdrinkinggoal_from_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_setdrinkinggoal_from_menu ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_set_in_setgoal_from_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_set_in_setgoal_from_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6542"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                            Ios_franklin_Constants.default_set_menu).is_displayed()
            if goal_info:
                print("verify_set_in_setgoal_from_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_set_in_setgoal_from_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_in_setgoal_from_menu ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_input_box_in_setgoal_from_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_input_box_in_setgoal_from_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6547"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.set_goal_send_keys).is_displayed()
            if goal_info:
                print("verify_input_box_in_setgoal_from_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_input_box_in_setgoal_from_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_input_box_in_setgoal_from_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_navigation_setgoal_from_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_navigation_setgoal_from_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6745"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                            Ios_franklin_Constants.default_set_menu).is_displayed()
            if goal_info:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_navigation_setgoal_from_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_enter_in_setgoal_from_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_enter_in_setgoal_from_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6548"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.set_goal_send_keys).is_displayed()
            if goal_info:
                print("verify_enter_in_setgoal_from_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_enter_in_setgoal_from_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_enter_in_setgoal_from_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_setgoal_by_selection_equivalent_ml_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_setgoal_by_selection_equivalent_ml_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6567"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.goal_user_input_menu).send_keys('400')
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                            Ios_franklin_Constants.menu_setgoal_ml_value).is_displayed()
            if goal_info:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_setgoal_by_selection_equivalent_ml_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_default_oz_units_setgoal_from_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_default_oz_units_setgoal_from_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6563"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.goal_units_menu).is_displayed()
            if goal_info:
                print("verify_default_oz_units_setgoal_from_menu : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_default_oz_units_setgoal_from_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_default_oz_units_setgoal_from_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_predefined_oz_units_setgoal_from_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_predefined_oz_units_setgoal_from_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6564"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.goal_units_menu).is_displayed()
            if goal_info:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_predefined_oz_units_setgoal_from_menu : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_predefined_oz_units_setgoal_from_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_predefined_goal_values_setgoal_from_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_predefined_goal_values_setgoal_from_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6565"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.goal_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.goal_units_menu).is_displayed()
            if goal_info:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_predefined_goal_values_setgoal_from_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_withdraw_consent(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_withdraw_consent")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.withdraw_consent_screen).is_displayed()
            if goal_info:
                print("verify_click_withdraw_consent : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_click_withdraw_consent : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_withdraw_consent ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_withdraw_consent_text_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_withdraw_consent_text_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.withdraw_consent_screen).is_displayed()
            if goal_info:
                print("verify_withdraw_consent_text_withdraw_consent_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_withdraw_consent_text_withdraw_consent_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_withdraw_consent_text_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_back_arrow_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_back_arrow_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.withdraw_consent_back_screen).is_displayed()
            if goal_info:
                print("verify_back_arrow_withdraw_consent_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_back_arrow_withdraw_consent_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_back_arrow_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_back_arrow_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_back_arrow_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.withdraw_consent_back_screen).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).is_displayed()
            if goal_info:
                print("verify_click_back_arrow_withdraw_consent_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_click_back_arrow_withdraw_consent_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_back_arrow_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_improveapp_text_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_improveapp_text_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.improve_app).is_displayed()
            if goal_info:
                print("verify_improveapp_text_withdraw_consent_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_improveapp_text_withdraw_consent_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_improveapp_text_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_improveapp_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_improveapp_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.improve_app).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.improve_app).is_displayed()
            if goal_info:
                print("verify_click_improveapp_withdraw_consent_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_click_improveapp_withdraw_consent_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_improveapp_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_improveapp_button_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_improveapp_button_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.improve_app_button).is_displayed()
            if goal_info:
                print("verify_improveapp_button_withdraw_consent_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_improveapp_button_withdraw_consent_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_improveapp_button_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_improveapp_button_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_improveapp_button_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.improve_app_button).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.improve_app).is_displayed()
            if goal_info:
                print("verify_click_improveapp_button_withdraw_consent_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_click_improveapp_button_withdraw_consent_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_improveapp_button_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_improveapp_des_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_improveapp_des_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.improve_app_des).is_displayed()
            if goal_info:
                print("verify_improveapp_des_withdraw_consent_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_improveapp_des_withdraw_consent_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_improveapp_des_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_improveapp_des_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_improveapp_des_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.improve_app_des).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                            Ios_franklin_Constants.improve_app_overall_content).is_displayed()
            if goal_info:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_improveapp_des_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_improveapp_save_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_improveapp_save_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.improve_app_button).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu_withdraw_save).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.ok_button).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.improve_app_button).is_displayed()
            if goal_info:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_improveapp_save_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_improveapp_and_save_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_improveapp_and_save_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.improve_app_button).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu_withdraw_save).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.ok_button).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.improve_app_button).is_displayed()
            if goal_info:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_improveapp_and_save_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_save_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_save_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.menu_withdraw_save).is_displayed()
            if goal_info:
                print("verify_save_withdraw_consent_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_save_withdraw_consent_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_save_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_marketing_text_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_marketing_text_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.marketing).is_displayed()
            if goal_info:
                print("verify_marketing_text_withdraw_consent_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_marketing_text_withdraw_consent_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_marketing_text_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_marketing_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_marketing_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.marketing).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.marketing_button).is_displayed()
            if goal_info:
                print("verify_click_marketing_withdraw_consent_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_click_marketing_withdraw_consent_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_marketing_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_marketing_button_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_marketing_button_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.marketing_button).is_displayed()
            if goal_info:
                print("verify_marketing_button_withdraw_consent_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_marketing_button_withdraw_consent_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_marketing_button_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_marketing_button_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_marketing_button_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.marketing_button).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.marketing_button).is_displayed()
            if goal_info:
                print("verify_click_marketing_button_withdraw_consent_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_click_marketing_button_withdraw_consent_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_marketing_button_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_marketing_des_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_marketing_des_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.marketing_des).is_displayed()
            if goal_info:
                print("verify_marketing_des_withdraw_consent_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_marketing_des_withdraw_consent_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_marketing_des_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_marketing_des_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_marketing_des_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.marketing_des).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                            Ios_franklin_Constants.improve_app_overall_content).is_displayed()
            if goal_info:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_marketing_des_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_marketing_save_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_marketing_save_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.marketing_button).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu_withdraw_save).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.improve_app).is_displayed()
            if goal_info:
                print("verify_click_marketing_save_withdraw_consent_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_click_marketing_save_withdraw_consent_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_marketing_save_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_marketing_and_save_withdraw_consent_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_marketing_and_save_withdraw_consent_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.withdraw_consent_menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.marketing_button).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu_withdraw_save).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.improve_app).is_displayed()
            if goal_info:
                print("verify_click_marketing_and_save_withdraw_consent_screen : PASS")
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                print("verify_click_marketing_and_save_withdraw_consent_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_marketing_and_save_withdraw_consent_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_highlight_alcohol(self):
        '''
        This function verify the intake fluid highlight alcohol
        :return:
        '''
        print(" Execution Started : verify_intake_fluid_list")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4696"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.alcohol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).is_displayed()
            if goal:
                print("verify_intake_fluid_list : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_intake_fluid_list : FAIL")
                status = FAIL
                status_reason = "Unable to highlight the alcohol"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_intake_fluid_list ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_type_text(self):
        '''
        This function verify the Log your beverage type text in beverages
        :return:
        '''
        print(" Execution Started : verify_beverage_type_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4697"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.beverage_type).is_displayed()
            if goal:
                print("verify_beverage_type_text : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_beverage_type_text : FAIL")
                status = FAIL
                status_reason = "Unable to get the text 'Log your beverage type'"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_type_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_type_select_other(self):
        '''
        This function verify the intake fluid highlight others
        :return:
        '''
        print(" Execution Started : verify_beverage_type_select_other")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5979"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.other).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.beverage_type).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to select others"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_type_select_other ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_type_default_water(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_beverage_type_default_water")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5980"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.beverage_default_water).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying water as a default in beverages"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_type_default_water ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_type_select_tea(self):
        '''
        This function verify the intake fluid tea
        :return:
        '''
        print(" Execution Started : verify_beverage_type_select_tea")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6008"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.coffee).click()
            time.sleep(1)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).is_displayed()
            if goal:
                print("verify_beverage_type_select_tea : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_beverage_type_select_tea : FAIL")
                status = FAIL
                status_reason = "Unable to show beverage tea"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_type_select_tea ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_type_select_alcohol(self):
        '''
        This function verify the intake fluid alcohol
        :return:
        '''
        print(" Execution Started : verify_beverage_type_select_alcohol")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6009"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.alcohol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).is_displayed()
            if goal:
                print("verify_beverage_type_select_alcohol : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_beverage_type_select_alcohol : FAIL")
                status = FAIL
                status_reason = "Unable to click on alcohol"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_type_select_alcohol ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_type_select_carbonated(self):
        '''
        This function verify the intake fluid carbonated
        :return:
        '''
        print(" Execution Started : verify_beverage_type_select_carbonated")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6010"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.carbonated).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to select carbonated"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_type_select_carbonated ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_type_water(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_beverage_type_water")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6472"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.beverage_default_water).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying type water"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_type_water ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_type_tea(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_beverage_type_tea")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6473"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.beverage_type_tea).text
            if goal == 'Tea/Coffee':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying type water"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_type_tea ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_type_alcohol(self):
        '''
        This function verify the intake fluid type alcohol
        :return:
        '''
        print(" Execution Started : verify_beverage_type_alcohol")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6473"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.beverage_type_alchol).text
            if goal == 'Alcohol':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying type alcohol"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_type_alcohol ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_type_carbonated(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_beverage_type_carbonated")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6473"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.beverage_type_carbonated).text
            if goal == 'Carbonated Beverages':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying type carbonates"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_type_carbonated ", status, testcase_execution_time)
        return az_id, status, status_reason


    ##############4/4
    def verify_click_on_product_info_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_on_product_info_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.product_info_screen).is_displayed()
            if goal_info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_on_product_info_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_productinfo_text_in_product_info_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_productinfo_text_in_product_info_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.product_info_screen).is_displayed()
            if goal_info:
                print("verify_productinfo_text_in_product_info_screen : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_productinfo_text_in_product_info_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_productinfo_text_in_product_info_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_backbutton_product_info_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_backbutton_product_info_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.prdt_back_btn).is_displayed()
            if goal_info:
                print("verify_backbutton_product_info_screen : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_backbutton_product_info_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_backbutton_product_info_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_on_backbutton_product_info_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_on_backbutton_product_info_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.prdt_back_btn).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                            Ios_franklin_Constants.product_info_menu).is_displayed()
            if goal_info:
                print("verify_click_on_backbutton_product_info_screen : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_click_on_backbutton_product_info_screen : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_on_backbutton_product_info_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_catheter_training_text_in_top_of_product_info_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_catheter_training_text_in_top_of_product_info_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                            Ios_franklin_Constants.top_catheter_training).is_displayed()
            if goal_info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_catheter_training_text_in_top_of_product_info_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_catheter_training_dcm(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_catheter_training_dcm")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.catheter_documment).is_displayed()
            if goal_info:
                print("verify_catheter_training_dcm : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_catheter_training_dcm : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_catheter_training_dcm ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_catheter_training_top_learn(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_catheter_training_top_learn")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.catheter_first_learn).is_displayed()
            if goal_info:
                print("verify_catheter_training_top_learn : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_catheter_training_top_learn : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_catheter_training_top_learn ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_catheter_training_top_learn(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_catheter_training_top_learn")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            info =driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.catheter_first_learn).click()
            time.sleep(3)
            goal_info = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                            Ios_franklin_Constants.cather_convatec_link).is_displayed()
            if goal_info:
                print("verify_click_catheter_training_top_learn : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_click_catheter_training_top_learn : FAIL")
                status = FAIL
                status_reason = "Application not navigates to the web"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_catheter_training_top_learn ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_catheter_training_text_in_bottom(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_catheter_training_text_in_bottom")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                            Ios_franklin_Constants.catheter_bottom).is_displayed()
            if goal_info:
                print("verify_catheter_training_text_in_bottom : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_catheter_training_text_in_bottom : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_catheter_training_text_in_bottom ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_catheter_training_bottom_learn(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_catheter_training_bottom_learn")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                            Ios_franklin_Constants.catheter_second_learn).is_displayed()
            if goal_info:
                print("verify_catheter_training_bottom_learn : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_catheter_training_bottom_learn : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_catheter_training_bottom_learn ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_catheter_training_bottom_learn(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_catheter_training_bottom_learn")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter_second_learn).click()
            time.sleep(3)
            goal_info = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                            Ios_franklin_Constants.cather_convatec_link).is_displayed()
            if goal_info:
                print("verify_click_catheter_training_bottom_learn : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_click_catheter_training_bottom_learn : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_catheter_training_bottom_learn ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_meplus_support_top_text(self):
        '''
        This function verifies the navigation to catheter document in the menu
        :return: Tuple containing test status details
        '''
        print("Execution Started: verify_meplus_support_top_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.catheter_documment)
            time.sleep(2)
            # Swipe left to view the document
            size = driver.get_window_size()
            start_x = int(size['width'] * 0.8)
            end_x = int(size['width'] * 0.2)
            y = int(size['height'] * 0.5)
            action = TouchAction(driver)
            action.press(x=start_x, y=y).wait(500).move_to(x=end_x, y=y).release().perform()
            time.sleep(2)
            text = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                       Ios_franklin_Constants.meplus_support_swipe).is_displayed()
            if text:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Failed to swipe the catheter document"
        except Exception as error:
            status_reason = str(error)
            print("Error:", error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_meplus_support_top_text ", status, testcase_execution_time)
            return az_id, status, status_reason


    def verify_meplus_support_top_description(self):
        '''
        This function verifies the navigation to catheter document in the menu
        :return: Tuple containing test status details
        '''
        print("Execution Started: verify_meplus_support_top_description")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.catheter_documment)
            time.sleep(2)
            # Swipe left to view the document
            size = driver.get_window_size()
            start_x = int(size['width'] * 0.8)
            end_x = int(size['width'] * 0.2)
            y = int(size['height'] * 0.5)
            action = TouchAction(driver)
            action.press(x=start_x, y=y).wait(500).move_to(x=end_x, y=y).release().perform()
            time.sleep(2)
            description = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                              Ios_franklin_Constants.description).is_displayed()
            if description:
                print("verify_meplus_support_top_description : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_meplus_support_top_description : FAIL")
                status = FAIL
                status_reason = "Failed to swipe the catheter document"
        except Exception as error:
            status_reason = str(error)
            print("verify_meplus_support_top_description : FAIL")
            print("Error:", error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_meplus_support_top_description ", status, testcase_execution_time)
            return az_id, status, status_reason


    def verify_meplus_support_top_learn_text(self):
        '''
        This function verifies the navigation to catheter document in the menu
        :return: Tuple containing test status details
        '''
        print("Execution Started: verify_meplus_support_top_learn_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.catheter_documment)
            time.sleep(2)
            size = driver.get_window_size()
            start_x = int(size['width'] * 0.8)
            end_x = int(size['width'] * 0.2)
            y = int(size['height'] * 0.5)
            action = TouchAction(driver)
            action.press(x=start_x, y=y).wait(500).move_to(x=end_x, y=y).release().perform()
            time.sleep(2)
            text = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.meplus_top_learn_text).is_displayed()
            if text:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Failed to swipe the catheter document"
        except Exception as error:
            status_reason = str(error)
            print("Error:", error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_meplus_support_top_learn_text ", status, testcase_execution_time)
            return az_id, status, status_reason


    def verify_click_meplus_support_top_learn_text(self):
        '''
        This function verifies the navigation to catheter document in the menu
        :return: Tuple containing test status details
        '''
        print("Execution Started: verify_click_meplus_support_top_learn_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.catheter_documment)
            time.sleep(2)
            # Swipe left to view the document
            size = driver.get_window_size()
            start_x = int(size['width'] * 0.8)
            end_x = int(size['width'] * 0.2)
            y = int(size['height'] * 0.5)
            action = TouchAction(driver)
            action.press(x=start_x, y=y).wait(500).move_to(x=end_x, y=y).release().perform()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.meplus_top_learn_text).click()
            time.sleep(5)
            text = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                       Ios_franklin_Constants.meplus_learn_navigation).is_displayed()
            if text:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Failed to swipe the catheter document"
        except Exception as error:
            status_reason = str(error)
            print("Error:", error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_meplus_support_top_learn_text ", status, testcase_execution_time)
            return az_id, status, status_reason


    def verify_meplus_support_bottom_text(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_meplus_support_bottom_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                            Ios_franklin_Constants.meplus_support_text).is_displayed()
            if goal_info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_meplus_support_bottom_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_meplus_support_bottom_learn_text(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_meplus_support_bottom_learn_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                            Ios_franklin_Constants.meplus_learn_text).is_displayed()
            if goal_info:
                print("verify_meplus_support_bottom_learn_text : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_meplus_support_bottom_learn_text : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_meplus_support_bottom_learn_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_meplus_support_bottom_learn_text(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_meplus_support_bottom_learn_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.meplus_learn_text).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                            Ios_franklin_Constants.meplus_learn_navigation).is_displayed()
            if goal_info:
                print("verify_click_meplus_support_bottom_learn_text : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_click_meplus_support_bottom_learn_text : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_meplus_support_bottom_learn_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_products_services_top_text(self):
        '''
        This function verifies the navigation to catheter document in the menu
        :return: Tuple containing test status details
        '''
        print("Execution Started: verify_products_services_top_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.catheter_documment)
            time.sleep(2)
            size = driver.get_window_size()
            start_x = int(size['width'] * 0.8)
            end_x = int(size['width'] * 0.2)
            y = int(size['height'] * 0.5)
            for s in range(2):
                action = TouchAction(driver)
                action.press(x=start_x, y=y).wait(500).move_to(x=end_x, y=y).release().perform()
            time.sleep(2)
            swipe = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                        Ios_franklin_Constants.products_top_text).is_displayed()
            if swipe:
                print("verify_products_services_top_text : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_products_services_top_text : FAIL")
                status = FAIL
                status_reason = "swipe not performed well"
        except Exception as error:
            status_reason = str(error)
            print("verify_products_services_top_text : FAIL")
            status = FAIL

        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_products_services_top_text ", status, testcase_execution_time)
            return az_id, status, status_reason


    def verify_products_services_top_description(self):
        '''
        This function verifies the navigation to catheter document in the menu
        :return: Tuple containing test status details
        '''
        print("Execution Started: verify_products_services_top_description")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.catheter_documment)
            time.sleep(2)
            size = driver.get_window_size()
            start_x = int(size['width'] * 0.8)
            end_x = int(size['width'] * 0.2)
            y = int(size['height'] * 0.5)
            for s in range(2):
                action = TouchAction(driver)
                action.press(x=start_x, y=y).wait(500).move_to(x=end_x, y=y).release().perform()
            time.sleep(2)
            swipe = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.description).is_displayed()
            if swipe:
                print("verify_products_services_top_description : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_products_services_top_description : FAIL")
                status = FAIL
                status_reason = "swipe not performed well"
        except Exception as error:
            status_reason = str(error)
            print("verify_products_services_top_description : FAIL")
            status = FAIL

        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_products_services_top_description ", status, testcase_execution_time)
            return az_id, status, status_reason


    def verify_products_services_top_learn_text(self):
        '''
        This function verifies the navigation to catheter document in the menu
        :return: Tuple containing test status details
        '''
        print("Execution Started: verify_products_services_top_learn_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.catheter_documment)
            time.sleep(2)
            size = driver.get_window_size()
            start_x = int(size['width'] * 0.8)
            end_x = int(size['width'] * 0.2)
            y = int(size['height'] * 0.5)
            for s in range(2):
                action = TouchAction(driver)
                action.press(x=start_x, y=y).wait(500).move_to(x=end_x, y=y).release().perform()
            time.sleep(2)
            swipe = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                        Ios_franklin_Constants.products_top_learn_text).is_displayed()
            if swipe:
                print("verify_products_services_top_learn_text : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_products_services_top_learn_text : FAIL")
                status = FAIL
                status_reason = "swipe not performed well"
        except Exception as error:
            status_reason = str(error)
            print("verify_products_services_top_learn_text : FAIL")
            status = FAIL

        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_products_services_top_learn_text ", status, testcase_execution_time)
            return az_id, status, status_reason


    def verify_click_products_services_top_learn_text(self):
        '''
        This function verifies the navigation to catheter document in the menu
        :return: Tuple containing test status details
        '''
        print("Execution Started: verify_click_products_services_top_learn_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.catheter_documment)
            time.sleep(2)
            size = driver.get_window_size()
            start_x = int(size['width'] * 0.8)
            end_x = int(size['width'] * 0.2)
            y = int(size['height'] * 0.5)
            for s in range(2):
                action = TouchAction(driver)
                action.press(x=start_x, y=y).wait(500).move_to(x=end_x, y=y).release().perform()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.products_top_learn_text).click()
            time.sleep(2)
            info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                       Ios_franklin_Constants.products_learn_navigation).is_displayed()
            if info:
                print("verify_click_products_services_top_learn_text : PASS")
                status = PASS
                status_reason = "Test Successful"
            else:
                print("verify_click_products_services_top_learn_text : FAIL")
                status = FAIL
                status_reason = "swipe not performed well"
        except Exception as error:
            status_reason = str(error)
            print("verify_click_products_services_top_learn_text : FAIL")
            status = FAIL

        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_products_services_top_learn_text ", status, testcase_execution_time)
            return az_id, status, status_reason


    def verify_products_bottom_text(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_products_bottom_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.products).is_displayed()
            if goal_info:
                print("verify_products_bottom_text : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_products_bottom_text : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_products_bottom_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_products_bottom_learn_text(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_products_bottom_learn_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(5)
            goal_info = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                            Ios_franklin_Constants.products_learn_text).is_displayed()
            if goal_info:
                print("verify_products_bottom_learn_text : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_products_bottom_learn_text : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_products_bottom_learn_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_products_bottom_learn_text(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_products_bottom_learn_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.product_info_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.products_learn_text).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                            Ios_franklin_Constants.products_learn_navigation).is_displayed()
            if goal_info:
                print("verify_click_products_bottom_learn_text : PASS")
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                print("verify_click_products_bottom_learn_text : FAIL")
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_products_bottom_learn_text ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_FAQ_text_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_FAQ_text_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7107"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_FAQ_text_menu ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_FAQ_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_FAQ_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7109"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.faq_text_faq_screen).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_FAQ_menu ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 292
    def verify_FAQ_text_FAQ_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_FAQ_text_FAQ_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7110"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.faq_text_faq_screen).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_FAQ_text_FAQ_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_back_button_FAQ_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_back_button_FAQ_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7111"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.faq_back_button).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_back_button_FAQ_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_back_button_FAQ_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_back_button_FAQ_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7112"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.faq_back_button).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_back_button_FAQ_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_search_icon_FAQ_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_search_icon_FAQ_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7113"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.faq_search).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_search_icon_FAQ_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_search_box_FAQ_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_search_box_FAQ_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7114"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.faq_search).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_search_box_FAQ_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_search_content_faqs(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_search_content_faqs")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7116"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.faq_search).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_search_content_faqs ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_search_FAQ_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_search_FAQ_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7115"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.faq_search).click()
            time.sleep(1)
            Info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.faq_text_faq_screen).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_search_FAQ_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_search_by_words_FAQ_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_search_by_words_FAQ_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7105"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.faq_search).send_keys('Catheter')
            time.sleep(2)
            Info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.search_catheter).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_search_by_words_FAQ_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_faqs_search_intermittent_catheter(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_faqs_search_intermittent_catheter")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7134"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.faq_search).send_keys('intermittent')
            time.sleep(2)
            Info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_searched_qn).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_faqs_search_intermittent_catheter ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_search_related_FAQs(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_search_related_FAQs")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7106"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.faq_search).send_keys('Catheter')
            time.sleep(2)
            Info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.search_catheter).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_search_related_FAQs ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_questions_in_FAQ_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_questions_in_FAQ_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7117"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.search_catheter).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_questions_in_FAQ_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_left_arrow_image(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_left_arrow_image")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7108"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.faq_back_button).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_left_arrow_image ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_search_content_FAQ_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_search_content_FAQ_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7118"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.search_catheter).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_search_content_FAQ_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_questions_format_in_FAQ_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_questions_format_in_FAQ_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7119"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.faq_search).send_keys('Catheter')
            time.sleep(2)
            Info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.search_catheter).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_questions_format_in_FAQ_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_default_questions_in_FAQ_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_default_questions_in_FAQ_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7120"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.default_faq_qns).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_default_questions_in_FAQ_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_dropdown_for_questions_in_FAQ_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_dropdown_for_questions_in_FAQ_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7121"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                       Ios_franklin_Constants.faq_questions_dropdown).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_dropdown_for_questions_in_FAQ_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_dropdown_for_questions_in_FAQ_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_dropdown_for_questions_in_FAQ_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7122"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.IOS_CLASS_CHAIN,
                                       Ios_franklin_Constants.faq_questions_dropdown).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_dropdown_for_questions_in_FAQ_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_on_privacy_policy(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_on_privacy_policy")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5680"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.privacy_policy_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.privacy_policy_back_button).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_on_privacy_policy ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_arrow_menu_privacy_policy(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_arrow_menu_privacy_policy")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7549"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:

            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.IOS_PREDICATE,Ios_franklin_Constants.privacy_policy_menu).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_arrow_menu_privacy_policy ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_back_button_privacy_policy(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_back_button_privacy_policy")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5680"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.privacy_policy_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.privacy_policy_back_button).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_back_button_privacy_policy ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_back_button_privacy_policy(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_back_button_privacy_policy")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7551"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.privacy_policy_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.privacy_policy_back_button).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                       Ios_franklin_Constants.privacy_policy_menu).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_back_button_privacy_policy ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_scroll_privacy_policy(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_scroll_privacy_policy")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7088"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.privacy_policy_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                       Ios_franklin_Constants.privacy_policy_document).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_scroll_privacy_policy ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_privacy_policy_text_privacy_policy_screen(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_privacy_policy_text_privacy_policy_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.privacy_policy_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                       Ios_franklin_Constants.privacy_policy_document).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_privacy_policy_text_privacy_policy_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_document_privacy_policy(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_document_privacy_policy")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.privacy_policy_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                       Ios_franklin_Constants.privacy_policy_document).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_document_privacy_policy ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_content_privacy_policy(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_content_privacy_policy")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7087"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.privacy_policy_menu).click()
            time.sleep(2)
            Info = driver.find_element(AppiumBy.IOS_PREDICATE,
                                       Ios_franklin_Constants.privacy_policy_document).is_displayed()
            if Info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_content_privacy_policy ", status, testcase_execution_time)
        return az_id, status, status_reason

    #######need to add 10/4
    def verify_click_how_to_use(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_how_to_use")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.record).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_how_to_use ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_text_how_to_use(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_record_text_how_to_use")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.record).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_text_how_to_use ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_image_how_to_use(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_record_image_how_to_use")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_image).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_image_how_to_use ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_description_how_to_use(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_record_entry_description_how_to_use")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.IOS_PREDICATE,
                                      Ios_franklin_Constants.record_entry_description).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_description_how_to_use ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_next_text(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_record_entry_next_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_next_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_record_entry_next_button(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_record_entry_next_button")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.share_reports).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_record_entry_next_button ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_skip_text(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_record_entry_skip_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_skip).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "walkthrough is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_skip_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_record_entry_skip_button(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_record_entry_skip_button")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_skip).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.recordentry_1).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "walkthrough is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_record_entry_skip_button ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_share_reports_text(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_share_reports_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.share_reports).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "walkthrough is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_reports_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_share_reports_walkthrough_image(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_share_reports_walkthrough_image")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_reports_image).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "walkthrough is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_reports_walkthrough_image ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_share_reports_walkthrough_description(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_share_reports_walkthrough_description")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.IOS_PREDICATE,
                                      Ios_franklin_Constants.share_reports_description).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "walkthrough is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_reports_walkthrough_description ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_share_reports_next_text(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_share_reports_next_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_reports_next_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_share_reports_next_button(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_share_reports_next_button")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.faq_product_info).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_reports_next_button ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_share_reports_skip_text(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_share_reports_skip_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_skip).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "walkthrough is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_share_reports_skip_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_share_reports_skip_button(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_share_reports_skip_button")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_skip).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.recordentry_1).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "walkthrough is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_reports_skip_button ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_product_info_and_faq_text(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_product_info_and_faq_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.faq_product_info).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_product_info_and_faq_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_product_info_and_faq_image(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_product_info_and_faq_image")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.IOS_PREDICATE,
                                      Ios_franklin_Constants.faq_product_info_image).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_product_info_and_faq_image ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_product_info_and_faq_description(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_product_info_and_faq_description")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                      Ios_franklin_Constants.faq_product_info_description).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_product_info_and_faq_description ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_product_info_and_faq_start_text(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_product_info_and_faq_start_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(2)
            use = driver.find_element(AppiumBy.IOS_PREDICATE,
                                      Ios_franklin_Constants.faq_product_info_start).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_product_info_and_faq_start_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_product_info_and_faq_start_text(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_click_product_info_and_faq_start_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.how_to_use).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry_next).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.faq_product_info_start).click()
            time.sleep(4)
            use = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.recordentry_1).is_displayed()
            if use:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Faq is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_product_info_and_faq_start_text ", status, testcase_execution_time)
        return az_id, status, status_reason

    # 11/4 NEEDDD TO ADDDDDDDDD
    def verify_click_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_click_edit_profile")
        status = NOT_EXECUTED
        tc_start_time = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(3)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.edit_text_editscreen).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_back_button_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_back_button_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.edit_back_button).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_back_button_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_back_button_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_click_back_button_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.edit_back_button).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.menu_userprofile_edit).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_back_button_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_save_with_invalid_data_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_click_save_with_invalid_data_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.Age_field).send_keys('@#$')
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.edit_done_button).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.edit_save).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.Age_field).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_save_with_invalid_data_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_first_name_text_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_first_name_text_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.First_name_text).text
            if username == 'First Name':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_first_name_text_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edit_first_name_edit_profile(self):

        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_edit_first_name_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,Ios_franklin_Constants.First_name_field)
            username.click()
            username.send_keys(Keys.BACKSPACE)
            time.sleep(2)
            username.send_keys("Sindhu")
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.edit_done_button).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.edit_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.ok_button).click()
            time.sleep(2)
            name=driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.meplus_userprofile_check).text
            if name == "Sindhu" :
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edit_first_name_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edited_first_name_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_edited_first_name_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.First_name_field).click()
            time.sleep(1)
            # driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.First_name_field).clear()
            time.sleep(1)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.First_name_text).text
            if username == 'First Name':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edited_first_name_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_last_name_text_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_last_name_text_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.last_name_text).text
            if username == 'Last Name':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_last_name_text_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edit_last_name_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_edit_last_name_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.First_name_field)
            username.click()
            username.send_keys(Keys.BACKSPACE)
            time.sleep(2)
            username.send_keys("P")
            print(username.text)
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edit_last_name_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edited_last_name_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_edited_last_name_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.last_name_text).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edited_last_name_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_mobile_number_text_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_mobile_number_text_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.mobile_number_field).is_displayed()
            if username  :
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_mobile_number_text_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edit_mobile_number_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_edit_mobile_number_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.mobile_number_field).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edit_mobile_number_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edited_mobile_number_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_edited_mobile_number_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.mobile_number_field).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edited_mobile_number_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    ###12/4
    def verify_email_text_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_email_text_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.email_text_edit).text
            if username == 'Email':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_email_text_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edit_email_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_edit_email_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.email_text_edit).text
            if username == 'Email':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edit_email_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edited_email_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_edited_email_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.email_text_edit).text
            if username == 'Email':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edited_email_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_age_text_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_age_text_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.age_text_edit).text
            if username == 'Age':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_age_text_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edit_age_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_edit_age_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.age_text_edit).text
            if username == 'Age':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edit_age_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edited_age_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_edited_age_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Age_field).send_keys('25')
            time.sleep(1)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.age_text_edit).text
            if username == 'Age':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edited_age_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_gender_text_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_gender_text_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.gender_text_edit).text
            if username == 'Gender':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_gender_text_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edit_gender_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_edit_gender_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.gender_text_edit).text
            if username == 'Gender':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edit_gender_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edited_gender_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_edited_gender_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(3)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(5)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.gender_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.female_text).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.edited_gender).is_displayed()
            if username :
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edited_gender_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_gender_dropdown_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_gender_dropdown_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.gender_dropdown).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.male_text).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_gender_dropdown_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_male_text_dropdown_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_male_text_dropdown_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.gender_dropdown).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.male_text).text
            if username == 'MALE':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_male_text_dropdown_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_male_text_dropdown_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_click_male_text_dropdown_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.gender_dropdown).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.male_text).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.edited_gender).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_male_text_dropdown_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_female_text_dropdown_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_female_text_dropdown_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.gender_dropdown).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.female_text).text
            if username == 'FEMALE':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_female_text_dropdown_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_female_text_dropdown_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_click_female_text_dropdown_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.gender_dropdown).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.female_text).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.edited_gender).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_female_text_dropdown_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_other_text_dropdown_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_other_text_dropdown_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.gender_dropdown).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.other_text).text
            if username == 'OTHER':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_other_text_dropdown_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_other_text_dropdown_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_click_other_text_dropdown_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.gender_dropdown).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.other_text).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.edited_gender).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_other_text_dropdown_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_unknown_text_dropdown_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_unknown_text_dropdown_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.gender_dropdown).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.unknown_text).text
            if username == 'UNKNOWN':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_unknown_text_dropdown_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_unknown_text_dropdown_edit_profile(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_click_unknown_text_dropdown_edit_profile")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.menu_userprofile_edit).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.gender_dropdown).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.unknown_text).click()
            time.sleep(1)
            username = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.edited_gender).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to edit profile"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_unknown_text_dropdown_edit_profile ", status, testcase_execution_time)
        return az_id, status, status_reason


    #####15/4 NEED TO ADD
    def verify_update_text(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_update_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.update_menu).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to update password"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_update_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_update_password_text_update_screen(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_update_password_text_update_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.update_menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.update_password).text
            if username == 'Update Password':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to update password"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_update_password_text_update_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_back_button_update_screen(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_back_button_update_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.update_menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.update_back_button).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to update password"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_back_button_update_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_back_button_update_screen(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_click_back_button_update_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.update_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.update_back_button).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.update_menu).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to update password"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_back_button_update_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_old_password_text_update_screen(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_old_password_text_update_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.update_menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.old_password_text).text
            if username == 'Old Password':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to update password"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_old_password_text_update_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_new_password_text_update_screen(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_new_password_text_update_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.update_menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.new_password_text).text
            if username == 'New Password':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to update password"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_new_password_text_update_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_confirm_new_password_text_update_screen(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_confirm_new_password_text_update_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.update_menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.confirm_new_password_text).text
            if username == 'Confirm New Password':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to update password"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_confirm_new_password_text_update_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_old_password_field_update_screen(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_old_password_field_update_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.update_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.old_password_field).send_keys(
                'Sindhuja@21')
            time.sleep(2)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.old_password_text).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to update password"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_old_password_field_update_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_new_password_field_update_screen(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_new_password_field_update_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.update_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.new_password_field).send_keys(
                'Sindhuja@12')
            time.sleep(2)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.old_password_text).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to update password"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_new_password_field_update_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_confirm_new_password_field_update_screen(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_confirm_new_password_field_update_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.update_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.confirm_new_password_field).send_keys(
                'Sindhuja@12')
            time.sleep(2)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.old_password_text).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to update password"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_confirm_new_password_field_update_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_update_text_update_screen(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_update_text_update_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.update_menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.update_text).text
            if username == 'UPDATE':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to update password"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_update_text_update_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_update_text_update_screen(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_click_update_text_update_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.update_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.update_text).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.update_text).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to update password"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_update_text_update_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_delete_text(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_delete_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7228"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.delete_profile_text).text
            if username == 'DELETE PROFILE':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to delete screen"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_delete_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_delete_text(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_click_delete_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7229"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.delete_profile_text).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.delete_user_text).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to delete screen"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_delete_text ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_delete_confirmation_text(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_delete_confirmation_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7234"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.delete_profile_text).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.delete_description).text
            if username == 'Are you sure, you want to delete your profile?':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to delete screen"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_delete_confirmation_text ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_delete_description(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_delete_description")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7230"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.delete_profile_text).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.delete_description).text
            if username == 'Are you sure, you want to delete your profile?':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to delete screen"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_delete_description ", status, testcase_execution_time)
        return az_id, status, status_reason



    def verify_delete_cancel_text(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_delete_cancel_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7232"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.delete_profile_text).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.delete_cancel).text
            if username == 'CANCEL':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to delete screen"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_delete_cancel_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_delete_click_cancel_text(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_delete_click_cancel_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7236"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.delete_profile_text).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.delete_cancel).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                           Ios_franklin_Constants.delete_profile_text).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to delete screen"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_delete_click_cancel_text ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_delete_highlighted_delete_screen(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_delete_highlighted_delete_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7235"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.delete_profile_text).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.delete_text_deletescreen).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to delete screen"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_delete_highlighted_delete_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_delete_delete_screen(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_delete_delete_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7231"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.delete_profile_text).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.delete_text_deletescreen).is_displayed()
            if username :
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to delete screen"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_delete_delete_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_delete_user_delete_screen(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_delete_user_delete_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7233"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.username_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.delete_profile_text).click()
            time.sleep(2)
            username = driver.find_element(AppiumBy.IOS_PREDICATE,
                                           Ios_franklin_Constants.delete_text_deletescreen).is_displayed()
            if username:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not navigates to delete screen"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_delete_user_delete_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_beverage_text_type_water(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_beverage_text_type_water")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6481"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            beverage = driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.beverage_default_water).is_displayed()
            if beverage :
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying beverage as a fluid"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_text_type_water ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_highlight_carbonated(self):
        '''
        This function verify the intake fluid highlight carbonates
        :return:
        '''
        print(" Execution Started : verify_beverage_highlight_carbonated")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6482"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.carbonated).click()
            time.sleep(1)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.carbonated).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to display carbonates"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_type_carbonated ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_highlight_other(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_beverage_highlight_other")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6483"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.other).click()
            time.sleep(1)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.other).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to highlight others in beverages"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_highlight_other ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_date_field(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_beverage_date_field")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5986"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(1)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Beverage date field is not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_date_field ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_current_field(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_beverage_current_field")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5987"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(1)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.current_time).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to display current time field in beverage"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_current_field ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_date_and_time_text(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_beverage_date_and_time_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6489"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(1)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).text
            if goal == 'Date & Time':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to display current date nd time texts"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_date_and_time_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_calender_icon(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_beverage_calender_icon")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6492"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(1)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying calender icon"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_calender_icon ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_beverage_clock_icon(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_beverage_clock_icon")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6493"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(1)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.current_time).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying time icon"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_beverage_clock_icon ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_leak_Delete_day_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_click_leak_Delete_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6957"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_delete).click()
            time.sleep(2)
            goal =driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_delete_icon).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to delete leak data in daysummary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_leak_Delete_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_leak_Delete_toast_day_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_leak_Delete_toast_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6957"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_delete_icon).click()
            time.sleep(3)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leeak_delete_toast).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying leak delete"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_leak_Delete_toast_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_leak_Delete_week_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_click_leak_Delete_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6958"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.day_in_week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_delete).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_delete_icon).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leeak_delete_toast).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to delete leak data in weeksummary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_leak_Delete_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_leak_Delete_month_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_click_leak_Delete_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6959"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.day_in_week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.day_in_week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_delete_icon).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leeak_delete_toast).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to delete leak data in monthsummary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_leak_Delete_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_leak_Delete_custom_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_click_leak_Delete_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6960"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.day_in_week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.day_in_week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_delete_icon).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leeak_delete_toast).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to delete leak data in customsummary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_leak_Delete_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_beverage_Delete_day_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_click_beverage_Delete_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6060"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.coffee).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.water).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.delete_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to delete beverage data in daysummary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_beverage_Delete_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_beverage_Delete_week_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_click_beverage_Delete_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6061"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.coffee).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.water).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.day_in_week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_delete).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.total_data).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to delete beverage data in weeksummary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_beverage_Delete_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_beverage_Delete_month_summary(self):
        '''
        This function verify the delete a beverage data from month summary
        :return:
        '''
        print(" Execution Started : verify_click_beverage_Delete_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6062"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.coffee).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.water).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.day_in_week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.delete_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.delete_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to delete beverage data in monthsummary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_beverage_Delete_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_beverage_Delete_custom_summary(self):
        '''
        This function verify the deleteing beverage data from custom summary
        :return:
        '''
        print(" Execution Started : verify_click_beverage_Delete_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6063"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.coffee).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.water).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.day_in_week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.day_in_week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.total_data).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to delete beverage data in customsummary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_beverage_Delete_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_Delete_icon_beverage_day_summary(self):
        '''
        This function verify the delete icon in beverage
        :return:
        '''
        print(" Execution Started : verify_Delete_icon_beverage_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6514"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.coffee).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.water).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.delete_icon).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying beverage delete icon in day summary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Delete_icon_beverage_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_Delete_icon_beverage_week_summary(self):
        '''
        This function verify the delete icon in week summary for beverage
        :return:
        '''
        print(" Execution Started : verify_Delete_icon_beverage_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6515"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.coffee).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.water).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.day_in_week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_delete).click()
            time.sleep(3)
            goal=driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "unable find the delete icon in week summaru beverage"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Delete_icon_beverage_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_Delete_icon_beverage_month_summary(self):
        '''
        This function verify the delete icon in beverage month summary
        :return:
        '''
        print(" Execution Started : verify_Delete_icon_beverage_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6516"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.coffee).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.water).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.delete_icon).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "unable find the delete icon"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Delete_icon_beverage_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_Delete_icon_beverage_custom_summary(self):
        '''
        This function verify the delete icon for custom summary in beverage data
        :return:
        '''
        print(" Execution Started : verify_Delete_icon_beverage_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6517"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.coffee).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.water).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.day_in_week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.delete_icon).click()
            time.sleep(2)
            goal=driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying beverage delete icon in custom summary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Delete_icon_beverage_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_set_hydration_goal_dashboard(self):
        '''
        This function verify setting hydration goal
        :return:
        '''
        print(" Execution Started : verify_set_hydration_goal_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6744"
        driver = desired_caps_IOS(self.serial)
        print("after desired caps")
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_hydration_goal_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_set_daily_goal_dashboard(self):
        '''
        This function verify setting hydration goal
        :return:
        '''
        print(" Execution Started : verify_set_daily_goal_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5858"
        driver = desired_caps_IOS(self.serial)
        print("after desired caps")
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.goal_screen_menu).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            print(az_id, "verify_set_daily_goal_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_exit_goal_settings_screen(self):
        '''
        The function verify the cancel hydration goal without goal
        :return:
        '''
        print(" Execution Started : verify_exit_goal_settings_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5863"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.cancel_goal).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()

            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_exit_goal_settings_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_set_text_daily_goal_dashboard(self):
        '''
        This function verify setting hydration goal
        :return:
        '''
        print(" Execution Started : verify_set_text_daily_goal_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5859"
        driver = desired_caps_IOS(self.serial)
        print("after desired caps")
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.goal_screen_menu).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_text_daily_goal_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_set_button_default_daily_goal_dashboard(self):
        '''
        This function verify setting hydration goal
        :return:
        '''
        print(" Execution Started : verify_set_button_default_daily_goal_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5852"
        driver = desired_caps_IOS(self.serial)
        print("after desired caps")
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.default_set_menu).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_button_default_daily_goal_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_input_field_set_goal_dashboard(self):
        '''
        This function verify the set hydration goal by user input menu
        :return:
        '''
        print(" Execution Started : verify_input_field_set_goal_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5871"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.set_goal_send_keys).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration goal by user input menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_input_field_set_goal_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_cancel_goal_screen(self):
        '''
        The function verify the cancel hydration goal without goal
        :return:
        '''
        print(" Execution Started : verify_cancel_goal_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4046"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.cancel_goal).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()

            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_cancel_goal_screen ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_set_hydration_goal_by_dashboard_selection(self):
        '''
        This function verify setting hydration goal
        :return:
        '''
        print(" Execution Started : verify_set_hydration_goal_by_dashboard_selection")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5861"
        driver = desired_caps_IOS(self.serial)
        print("after desired caps")
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.enter_goal).send_keys('234')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_hydration_goal_by_dashboard_selection ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_set_daily_goal_dashboard(self):
        '''
        This function verify setting hydration goal
        :return:
        '''
        print(" Execution Started : verify_click_set_daily_goal_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5866"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.enter_goal).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_set_daily_goal_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_set_enable_user_input_dashboard(self):
        '''
        This function verify the set hydration goal by user input menu
        :return:
        '''
        print(" Execution Started : verify_set_enable_user_input_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5853"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.enter_goal).send_keys('234')
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal_key).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration goal by user input menu"
        except Exception as error:
            status =  NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_enable_user_input_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_set_enable_selection_dashboard(self):
        '''
        This function verify setting hydration goal
        :return:
        '''
        print(" Execution Started : verify_set_enable_selection_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5854"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.enter_goal).send_keys('234')
            time.sleep(1)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_enable_selection_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_set_action_goal_creation_dashboard(self):
        '''
        This function verify setting hydration goal
        :return:
        '''
        print(" Execution Started : verify_set_action_goal_creation_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3343"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.enter_goal).send_keys('234')
            time.sleep(1)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_action_goal_creation_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_set_hydration_goal_by_five_digit_user(self):
        '''
        This function verify setting hydration goal with user selection
        :return:
        '''
        print(" Execution Started : verify_set_hydration_goal_by_five_digit_user")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5594"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.enter_goal).send_keys('500')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).click()
            driver.implicitly_wait(6)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_hydration_goal_by_five_digit_user ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_set_hydration_goal_ml_equal_oz(self):
        '''
        This function verify setting hydration goal with user selection
        :return:
        '''
        print(" Execution Started : verify_set_hydration_goal_ml_equal_oz")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5855"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.enter_goal).send_keys('500')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set).click()
            driver.implicitly_wait(6)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_hydration_goal_ml_equal_oz ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_set_daily_goal_units_dashboard(self):
        '''
        This function verify setting hydration goal
        :return:
        '''
        print(" Execution Started : verify_set_daily_goal_units_dashboard")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5857"
        driver = desired_caps_IOS(self.serial)
        print("after desired caps")
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            goal=driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.goal_units_menu).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_daily_goal_units_dashboard ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_set_goal_oz_equal_ml_units(self):
        '''
        This function verify setting hydration goal with user selection
        :return:
        '''
        print(" Execution Started : verify_set_goal_oz_equal_ml_units")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6568"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.set_goal).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.enter_goal).send_keys('500')
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.goal_units_menu).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set hydration"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_set_goal_oz_equal_ml_units ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_yes_today_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_today_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6149'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_today_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_yes_disclaimer_today_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_disclaimer_today_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6137'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_disclaimer_today_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_share_no_today_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_no_today_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6150'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_no).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_no_today_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_share_yes_week_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_week_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6161'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_week_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_yes_disclaimer_week_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_disclaimer_week_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6141'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_disclaimer_week_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_no_week_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_no_week_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6162'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_no).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_no_week_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_share_yes_month_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_month_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6173'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_month_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_yes_disclaimer_month_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_disclaimer_month_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6145'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_disclaimer_month_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_no_month_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_no_month_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6174'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_no).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_no_month_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_share_yes_custom_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_custom_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6158'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.custom).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_custom_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_share_no_custom_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_no_custom_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6159'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.custom).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_no).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_no_custom_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_share_yes_today_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_today_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6152'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_today_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_yes_disclaimer_today_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_disclaimer_today_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6138'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_disclaimer_today_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_no_today_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_no_today_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6153'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_no).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_no_today_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_share_yes_today_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_today_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6155'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_today_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_yes_disclaimer_today_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_disclaimer_today_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6139'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_disclaimer_today_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_share_no_today_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_no_today_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6156'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_no).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_no_today_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_share_yes_today_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_today_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6158'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_today_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_yes_disclaimer_today_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_disclaimer_today_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6140'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_disclaimer_today_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_yes_disclaimer_today_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_disclaimer_today_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6140'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_disclaimer_today_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_no_today_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_no_today_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6159'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_no).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_no_today_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_share_yes_week_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_week_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6164'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_week_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_yes_disclaimer_week_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_disclaimer_week_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6142'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_disclaimer_week_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_no_week_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_no_week_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6165'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_no).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_no_week_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_share_yes_week_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_week_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6167'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_week_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_yes_disclaimer_week_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_disclaimer_week_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6143'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_disclaimer_week_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_no_week_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_no_week_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6168'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_no).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_no_week_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_share_yes_week_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_week_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6170'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_week_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_yes_disclaimer_week_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_disclaimer_week_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6144'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_disclaimer_week_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_no_week_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_no_week_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6171'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_no).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_no_week_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_share_yes_month_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_month_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6176'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_month_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_yes_disclaimer_month_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_disclaimer_month_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6146'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_disclaimer_month_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_no_month_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_no_month_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6177'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_no).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_no_month_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_share_yes_month_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_month_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6179'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_month_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_yes_disclaimer_month_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_disclaimer_month_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6147'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_disclaimer_month_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_no_month_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_no_month_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6180'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_no).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_no_month_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_yes_month_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_yes_month_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6182'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_yes_month_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_share_no_month_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_click_share_no_month_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6183'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.month).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_no).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_click_share_no_month_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_list_apps_share_yes_today_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_list_apps_share_yes_today_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6185'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_list_apps_share_yes_today_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_list_apps_share_yes_today_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_list_apps_share_yes_today_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6186'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_list_apps_share_yes_today_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_list_apps_share_yes_today_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_list_apps_share_yes_today_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6187'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_list_apps_share_yes_today_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_list_apps_share_yes_today_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_list_apps_share_yes_today_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6188'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Today).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_list_apps_share_yes_today_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_list_apps_share_yes_custom_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_list_apps_share_yes_custom_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6197'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.custom).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_list_apps_share_yes_custom_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_list_apps_share_yes_custom_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_list_apps_share_yes_custom_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6198'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.custom).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_list_apps_share_yes_custom_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_list_apps_share_yes_custom_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_list_apps_share_yes_custom_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6199'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.custom).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification)
            if share.is_displayed():
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_list_apps_share_yes_custom_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_list_apps_share_yes_custom_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_list_apps_share_yes_custom_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        az_id = '6200'
        tc_start_time = get_current_time()
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Share_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.custom).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_yes).click()
            time.sleep(2)
            share = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.third_part_verification).is_displayed()
            if share:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_list_apps_share_yes_custom_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_about_franklin_tab_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_about_franklin_tab_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7021"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.About_app).is_displayed()
            if goal_info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_about_franklin_tab_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_about_franklin_arrow_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_about_franklin_arrow_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7022"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.About_app).is_displayed()
            if goal_info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_about_franklin_arrow_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_clicks_about_franklin_tab_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_clicks_about_franklin_tab_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7023"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.About_app).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.about_the_app).is_displayed()
            if goal_info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_clicks_about_franklin_tab_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_back_arrow_about_franklin(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_back_arrow_about_franklin")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7548"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.About_app).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.about_backbtn).is_displayed()
            if goal_info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_back_arrow_about_franklin ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_title_about_franklin(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_title_about_franklin")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7024"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.About_app).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.about_the_app).is_displayed()
            if goal_info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_title_about_franklin ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_franklin_text_about_franklin(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_franklin_text_about_franklin")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7547"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.About_app).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.app_des).is_displayed()
            if goal_info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_franklin_text_about_franklin ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_franklin_content_about_franklin(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_franklin_content_about_franklin")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7546"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.About_app).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.app_des).is_displayed()
            if goal_info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_franklin_content_about_franklin ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_disclaimer_text_about_franklin(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_disclaimer_text_about_franklin")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7020"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.About_app).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.app_disclaimer).is_displayed()
            if goal_info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_disclaimer_text_about_franklin ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_disclaimer_content_about_franklin(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_disclaimer_content_about_franklin")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7019"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.About_app).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.app_disclaimer).is_displayed()
            if goal_info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_disclaimer_content_about_franklin ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_navigates_menu_back_arrow(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_navigates_menu_back_arrow")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7025"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.About_app).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.about_backbtn).click()
            time.sleep(2)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).is_displayed()
            if goal_info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_navigates_menu_back_arrow ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_version_number_menu(self):
        '''
        This function verify the navigate to profile in menu
        :return:
        '''
        print(" Execution Started : verify_version_number_menu")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "8085"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(3)
            deviceSize = driver.get_window_size()
            screenWidth = deviceSize['width']
            screenHeight = deviceSize['height']
            startx = screenWidth / 2
            endx = screenWidth / 2
            starty = screenHeight * 8 / 9
            endy = screenHeight / 9
            driver.swipe(start_x=startx, start_y=starty, end_x=endx, end_y=endy, duration=100)
            time.sleep(5)
            goal_info = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                            Ios_franklin_Constants.app_version).is_displayed()
            if goal_info:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "user profile is not navigated in menu"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_version_number_menu ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edit_leak_day_summary(self):
        '''
        This function verify the editing the leak data in day summary
        :return:
        '''
        print(" Execution Started : verify_edit_leak_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7005"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_save_changes).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.summary_edit_date_today).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to edit the leak data in day summary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edit_leak_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edit_leak_week_summary(self):
        '''
        This function verify the editing the leak data in week summary
        :return:
        '''
        print(" Execution Started : verify_edit_leak_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7006"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_save_changes).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.catheter_count).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to edit the leak data in week summary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edit_leak_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_title_leak_details_day_summary(self):
        '''
        This function verify the leak deleails
        :return:
        '''
        print(" Execution Started : verify_title_leak_details_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.title_leak).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "leak title text missing"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_title_leak_details_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_delete_icon_leak_details_day_summary(self):
        '''
        This function verify the delete icon for day summary
        :return:
        '''
        print(" Execution Started : verify_delete_icon_leak_details_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6969"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.leak_delete_icon).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "missing delete icon in leak edit screen"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_delete_icon_leak_details_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edit_icon_leak_details_day_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_edit_icon_leak_details_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.leak_edit_symbol).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_delete_icon_leak_details_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_date_time_heading_leak_details_day_summary(self):
        '''
        This function verify the date & time text
        :return:
        '''
        print(" Execution Started : verify_date_time_heading_leak_details_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to display date and time text in leak edit screen"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_date_time_heading_leak_details_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_date_time_value_leak_details_day_summary(self):
        '''
        This function verify the date and time value
        :return:
        '''
        print(" Execution Started : verify_date_time_value_leak_details_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to display date and time"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_date_time_value_leak_details_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_comments_heading_leak_details_day_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_comments_heading_leak_details_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying comments text"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_heading_leak_details_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_comments_value_leak_details_day_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_comments_value_leak_details_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying comments"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_value_leak_details_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_leak_delete_day_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_leak_delete_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6957"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_delete_icon).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.ok_button).click()
            time.sleep(3)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to delete leak"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_leak_delete_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_title_leak_details_week_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_title_leak_details_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_title_leak_details_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_delete_icon_leak_details_week_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_delete_icon_leak_details_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6970"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.leak_delete_icon).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying leak symbol"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_delete_icon_leak_details_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edit_icon_leak_details_week_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_edit_icon_leak_details_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.leak_edit_symbol).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying leak symbol"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edit_icon_leak_details_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_date_time_heading_leak_details_week_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_date_time_heading_leak_details_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying leak symbol"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_date_time_heading_leak_details_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_date_time_value_leak_details_week_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_date_time_value_leak_details_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_time_lable).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying leak symbol"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_date_time_value_leak_details_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_comments_heading_leak_details_week_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_comments_heading_leak_details_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying leak symbol"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_heading_leak_details_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_comments_value_leak_details_week_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_comments_value_leak_details_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying leak symbol"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_value_leak_details_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_leak_delete_week_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_leak_delete_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6958"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_delete_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.ok_button).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.title_leak).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying leak symbol"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_leak_delete_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_title_leak_details_month_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_title_leak_details_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.title_leak).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_title_leak_details_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_delete_icon_leak_details_month_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_delete_icon_leak_details_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6971"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Latest_month_top).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.leak_delete_icon).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_delete_icon_leak_details_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edit_icon_leak_details_month_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_edit_icon_leak_details_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Latest_month_top).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.leak_edit_symbol).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edit_icon_leak_details_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_date_time_heading_leak_details_month_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_date_time_heading_leak_details_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Latest_month_top).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_date_time_heading_leak_details_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_date_time_value_leak_details_month_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_date_time_value_leak_details_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Latest_month_top).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_time_lable).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_date_time_value_leak_details_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_comments_heading_leak_details_month_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_comments_heading_leak_details_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Latest_month_top).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_heading_leak_details_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_comments_value_leak_details_month_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_comments_value_leak_details_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Latest_month_top).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_value_leak_details_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_leak_delete_month_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_leak_delete_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6959"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Latest_month_top).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_delete_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.ok_button).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.title_leak).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_leak_delete_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_title_leak_details_custom_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_title_leak_details_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.title_leak).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_title_leak_details_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_delete_icon_leak_details_custom_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_delete_icon_leak_details_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6972"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.leak_delete_icon).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "delete icon not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_delete_icon_leak_details_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_edit_icon_leak_details_custom_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_edit_icon_leak_details_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.leak_edit_symbol).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "delete icon not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_edit_icon_leak_details_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_date_time_heading_leak_details_custom_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_date_time_heading_leak_details_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "delete icon not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_date_time_heading_leak_details_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_date_time_value_leak_details_custom_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_date_time_value_leak_details_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_time_lable).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "delete icon not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_date_time_value_leak_details_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_comments_heading_leak_details_custom_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_comments_heading_leak_details_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "delete icon not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_heading_leak_details_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_comments_value_leak_details_custom_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_comments_value_leak_details_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "delete icon not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_value_leak_details_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_leak_delete_custom_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_leak_delete_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6960"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_delete_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.ok_button).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.title_leak).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "delete icon not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_leak_delete_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_title_leak_edit_day_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_title_leak_edit_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.title_leak).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_title_leak_edit_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_date_time_heading_leak_edit_day_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_date_time_heading_leak_edit_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_date_time_heading_leak_edit_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_comments_heading_leak_edit_day_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_comments_heading_leak_edit_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).text
            if goal == 'Comments':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_heading_leak_edit_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_comments_input_text_leak_edit_day_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_comments_input_text_leak_edit_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_input_text_leak_edit_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_save_text_leak_edit_day_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_save_text_leak_edit_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save_changes).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_save_text_leak_edit_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_cancel_text_leak_edit_day_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_cancel_text_leak_edit_day_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_cancel).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_cancel_text_leak_edit_day_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_title_leak_edit_week_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_title_leak_edit_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_title_leak_edit_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_date_time_heading_leak_edit_week_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_date_time_heading_leak_edit_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying leak symbol"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_date_time_heading_leak_edit_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_comments_heading_leak_edit_week_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_comments_heading_leak_edit_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying leak symbol"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_heading_leak_edit_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_comments_input_text_leak_edit_week_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_comments_input_text_leak_edit_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying leak symbol"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_input_text_leak_edit_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_save_text_leak_edit_week_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_save_text_leak_edit_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save_changes).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying leak symbol"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_save_text_leak_edit_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_cancel_text_leak_edit_week_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_cancel_text_leak_edit_week_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_cancel).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not displaying leak symbol"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_cancel_text_leak_edit_week_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_title_leak_edit_month_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_title_leak_edit_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.title_leak).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_title_leak_edit_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_date_time_heading_leak_edit_month_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_date_time_heading_leak_edit_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Latest_month_top).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_date_time_heading_leak_edit_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_comments_heading_leak_edit_month_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_comments_heading_leak_edit_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Latest_month_top).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_heading_leak_edit_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_comments_input_text_leak_edit_month_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_comments_input_text_leak_edit_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Latest_month_top).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).text
            if goal == 'Comments':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_input_text_leak_edit_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_save_text_leak_edit_month_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_save_text_leak_edit_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Latest_month_top).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            save = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save_changes).text
            if save == 'SAVE CHANGES':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_save_text_leak_edit_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_cancel_text_leak_edit_month_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_cancel_text_leak_edit_month_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Latest_month_top).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.edit_weeksummary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            cancel = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_cancel).text
            if cancel == 'CANCEL':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_cancel_text_leak_edit_month_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_title_leak_edit_custom_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_title_leak_edit_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.title_leak).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_title_leak_edit_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_date_and_time_heading_leak_details_custom_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_date_and_time_heading_leak_details_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "delete icon not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_date_and_time_heading_leak_details_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_comments_heading_leak_edit_custom_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_comments_heading_leak_edit_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "delete icon not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_heading_leak_edit_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_comments_input_text_leak_edit_custom_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_comments_input_text_leak_edit_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            cancel  = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).is_displayed()
            if cancel:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "delete icon not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_input_text_leak_edit_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_save_text_leak_edit_custom_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_save_text_leak_edit_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            save = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save_changes).text
            if save == 'SAVE CHANGES':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "delete icon not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_save_text_leak_edit_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_cancel_text_leak_edit_custom_summary(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_cancel_text_leak_edit_custom_summary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Edit_screen_navigation).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_edit_symbol).click()
            time.sleep(2)
            cancel = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_cancel).text
            if cancel == 'CANCEL':
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "delete icon not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_cancel_text_leak_edit_custom_summary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_record_entry_urine_text(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_urine_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4883"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(3)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.urine_text).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_urine_date_And_time_text(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_urine_date_And_time_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7884"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(3)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_date_And_time_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_urine_date_field(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_urine_date_field")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4865"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(3)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_date_field ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_urine_clock_field(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_urine_clock_field")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4866"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(3)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.current_time).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_clock_field ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_click_urine_date_field(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_click_urine_date_field")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7884"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_click_urine_date_field ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_urine_date_done_button(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_urine_date_done_button")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_date_done_button ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_urine_date_cancel_button(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_urine_date_cancel_button")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.Urine_date_cancel_button).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_date_cancel_button ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_urine_date_save_button(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_urine_date_save_button")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7882"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_date_save_button ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_urine_click_date_done_button(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_urine_click_date_done_button")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_click_date_done_button ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_urine_click_date_cancel_button(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_urine_click_date_cancel_button")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.Urine_date_cancel_button).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_click_date_cancel_button ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_click_urine_clock_field(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_click_urine_clock_field")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.current_time).click()
            time.sleep(1)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_click_urine_clock_field ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_urine_clock_done_button(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_urine_clock_done_button")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.current_time).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_clock_done_button ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_urine_clock_cancel_button(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_urine_clock_cancel_button")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.current_time).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.Urine_date_cancel_button).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_clock_cancel_button ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_urine_clock_save_button(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_urine_clock_save_button")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.current_time).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_clock_save_button ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_urine_click_clock_done_button(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_urine_click_clock_done_button")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.current_time).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.current_time).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_click_date_done_button ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_urine_click_clock_cancel_button(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_urine_click_clock_cancel_button")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.current_time).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.Urine_date_cancel_button).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.current_time).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_click_clock_cancel_button ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_urine_volume_text(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_urine_volume_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(3)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.urine_volume).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_volume_text ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_record_entry_urine_ml_units_text(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_urine_ml_units_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.urine_ml_text).click()
            time.sleep(1)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.urine_ml_text).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_ml_units_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_click_urine_ml_units_text(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_click_urine_ml_units_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.urine_ml_text).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.urine_ml_text).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_ml_units_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_urine_oz_units_text(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_urine_oz_units_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7170"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(3)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.urine_oz_text).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_urine_oz_units_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_click_urine_oz_units_text(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_click_urine_oz_units_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4860"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.urine_oz_text).click()
            time.sleep(1)
            goal = driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.urine_oz_text).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_click_urine_oz_units_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_comments_text(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_comments_text")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "8041"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_comments_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_comments_field(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_comments_field")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7885"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comments_input_field).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_comments_field ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_record_entry_comments_enter_input_field(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_record_entry_comments_enter_input_field")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "3207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comments_input_field).send_keys(
                'checking input comments ')
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.urine_volume).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE,
                                       Ios_franklin_Constants.leak_save_menu).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_record_entry_comments_enter_input_field ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_total_beverage_volume_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_beverage_volume_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4579"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.beverage_volume).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_beverage_volume_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_total_cathlogs_text_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_cathlogs_text_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7206"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.cathlogs_text).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_cathlogs_text_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_total_cathlogs_count_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_cathlogs_count_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7207"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.catheter_count).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_cathlogs_count_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_total_cathlogs_text_monthmmary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_cathlogs_text_monthmmary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7211"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.cathlogs_text).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_cathlogs_text_monthmmary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_total_cathlogs_count_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_cathlogs_count_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7210"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.total_beverage_volume).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_cathlogs_count_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_total_cathlogs_text_custommmary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_cathlogs_text_custommmary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7215"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.cathlogs_text).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_cathlogs_text_custommmary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_total_cathlogs_count_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_cathlogs_count_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7214"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.total_beverage_volume).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_cathlogs_count_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_total_urine_vol_count_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_urine_vol_count_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7186"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.Total_urine_data).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_urine_vol_count_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_total_urine_vol_text_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_urine_vol_text_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7187"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.Total_urine_data).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_urine_vol_text_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_total_urine_vol_text_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_urine_vol_text_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7193"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.Total_urine_data).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_urine_vol_text_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_total_urine_vol_count_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_urine_vol_count_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7192"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('3')
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('4')
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(3)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.Total_urine_data).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_urine_vol_count_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_total_urine_vol_count_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_urine_vol_count_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7198"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.Total_urine_data).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_urine_vol_count_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_total_urine_vol_text_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_urine_vol_text_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7199"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.Total_urine_data).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_urine_vol_text_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_indetails_void_data_click_arrow_in_monthsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_indetails_void_data_click_arrow_in_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "8018"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.total_data).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_indetails_void_data_click_arrow_in_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_indetails_void_data_click_arrow_in_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_indetails_void_data_click_arrow_in_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "8031"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.total_data).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_indetails_void_data_click_arrow_in_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_indetails_void_data_click_arrow_in_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_indetails_void_data_click_arrow_in_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "8005"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.Total_urine_data).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_indetails_void_data_click_arrow_in_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_headers_in_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_headers_in_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7984"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            headers = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.header_texts).is_displayed()
            if headers:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_headers_in_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_current_day_leak_record_entry_with_space_comment(self):
        '''
        This function verify the current day leak record entry
        :return:
        '''
        print(" Execution Started : verify_current_day_leak_record_entry_with_space_comment")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7004"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comments_input_field).send_keys('  ')
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.ok_button).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "not able to set current day leak record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_day_leak_record_entry_with_space_comment ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_current_day_leak_record_entry_current_day_time(self):
        '''
        This function verify the current day leak record entry
        :return:
        '''
        print(" Execution Started : verify_current_day_leak_record_entry_current_day_time")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7004"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_save_menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.ok_button).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "not able to set current day leak record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_day_leak_record_entry_current_day_time ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_note_leak_record_entry(self):
        '''
        This function verify the current day leak record entry
        :return:
        '''
        print(" Execution Started : verify_note_leak_record_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7004"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.leak_note).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "not able to set current day leak record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_note_leak_record_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_leak_in_leak_screen(self):
        '''
        This function verify the intake fluid list
        :return:
        '''
        print(" Execution Started : verify_leak_in_leak_screen")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7876"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.leak_text).text
            if goal == 'Leak':
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to select all fluids"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_leak_in_leak_screen ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_current_date_leak(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_current_date_leak")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4869"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_today).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "not able to verify leak record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_date_leak ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_current_time_leak(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_current_time_leak")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4870"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.current_time).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "not able to verify leak record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_time_leak ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_navigates_beverage_to_leak(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_navigates_beverage_to_leak")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6403"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.Beverage_value).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.leak_icon).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "not able to verify leak record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_navigates_beverage_to_leak ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_current_record_entry_catheter(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_current_record_entry_catheter")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7138"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('1')
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.register_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comments_input_field).send_keys(
                'record catheter value')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "not able to verify leak record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_record_entry_catheter ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_current_record_entry_naturally(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_current_record_entry_naturally")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7139"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('1')
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.register_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comments_input_field).send_keys(
                'record naturally value')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "not able to verify record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_record_entry_naturally ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_current_record_entry_both_naturally(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_current_record_entry_both_naturally")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7140"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('1')
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('1')
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comments_input_field).send_keys(
                'record for both cathter and naturally values')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "not able to verify both record entries"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_record_entry_both_naturally ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_current_record_entry_catheter_without_comments(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_current_record_entry_catheter_without_comments")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7141"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('1')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "not able to verify leak record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_record_entry_catheter_without_comments ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_current_record_entry_naturally_without_comments(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_current_record_entry_naturally_without_comments")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7142"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('1')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "not able to verify record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_record_entry_naturally_without_comments ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_current_record_entry_both_without_comments(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_current_record_entry_both_without_comments")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7143"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('1')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('1')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "not able to verify record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_current_record_entry_both_without_comments ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_urine_record_entry_both_without_comments(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_urine_record_entry_both_without_comments")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7154"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('1')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('1')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "not able to verify record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_urine_record_entry_both_without_comments ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_urine_current_record_entry_both_without_comments(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_urine_current_record_entry_both_without_comments")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7159"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('1')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('1')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.login_check).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "not able to verify record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_urine_current_record_entry_both_without_comments ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_save_text_record_entry(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_save_text_record_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7882"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(3)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).is_displayed()
            if goal :
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "save text not available"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_save_text_record_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_comments_text_record_entry(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_comments_text_record_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7883"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).text
            if goal == 'Comments':
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "comments text not available"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_comments_text_record_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_date_time_text_record_entry(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_date_time_text_record_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7884"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_and_time).text
            if goal == 'Date & Time':
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "date and time text not available"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_date_time_text_record_entry ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_enter_text_record_entry(self):
        '''
        This function verify the leak record entry
        :return:
        '''
        print(" Execution Started : verify_enter_text_record_entry")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7885"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.rec_entry).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.comment).text
            if goal == 'Comments':
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "enter text not available"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_enter_text_record_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_enter_four_digit_record_entry_for_beverage(self):
        '''
        This function verify the record entry for beverage value
        :return:
        '''
        print(" Execution Started : verify_enter_four_digit_record_entry_for_beverage")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6569"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.beverage).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.More).send_keys('1234')
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.edit_done_button).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry for beverage"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_enter_text_record_entry ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_indetails_beverage_data_in_customsummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_indetails_beverage_data_in_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6504"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.total_beverage_volume).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to get beverage value"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_indetails_beverage_data_in_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_indetails_beverage_data_in_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_indetails_beverage_data_in_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6501"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.total_beverage_volume).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_indetails_beverage_data_in_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_total_beverage_data_in_weeksummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_beverage_data_in_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6500"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.total_beverage_volume).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_beverage_data_in_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_total_cathlogs_text_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_cathlogs_text_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7184"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.cathlogs_text).text
            if goal == 'Cath Logs':
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_cathlogs_text_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_total__text_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_cathlogs_text_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7184"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.cathlogs_text).text
            if goal == 'Cath Logs':
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_cathlogs_text_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_total_urine_vol_count_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_urine_vol_count_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7185"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.Total_urine_data).is_displayed()
            if goal:
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_urine_vol_count_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_total_urine_vol_value_daysummary(self):
        '''
        This function verify the record an entry for void data
        :return:
        '''
        print(" Execution Started : verify_total_urine_vol_value_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "7183"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(3)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,Ios_franklin_Constants.Total_urine_data).text
            if goal == 'Urine Vol':
                status =  PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status =  FAIL
                status_reason = "Not able to set record entry"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_total_urine_vol_value_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_dairy_text_daysummary(self):
        '''
        This function verify summary in dashboard
        :return:
        '''
        print(" Execution Started : verify_dairy_text_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "5139"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.dairy).text
            if goal == 'Diary':
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Application not display summary"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_dairy_text_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_Delete_urine_entry_daysummary(self):
        '''
        This function verify the day summary urine value
        :return:
        '''
        print(" Execution Started : verify_Delete_urine_entry_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6395"
        driver = desired_caps_IOS(self.serial)
        time.sleep(7)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('3')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('4')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Indetail_day_in_custom).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.urine_delete_toast).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for urine data "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Delete_urine_entry_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_Delete_urine_entry_weeksummary(self):
        '''
        This function verify the day summary urine value
        :return:
        '''
        print(" Execution Started : verify_Delete_urine_entry_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6396"
        driver = desired_caps_IOS(self.serial)
        time.sleep(7)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('3')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('4')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Indetail_day_in_custom).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.urine_delete_toast).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for urine data "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Delete_urine_entry_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_Delete_urine_entry_monthsummary(self):
        '''
        This function verify the day summary urine value
        :return:
        '''
        print(" Execution Started : verify_Delete_urine_entry_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6397"
        driver = desired_caps_IOS(self.serial)
        time.sleep(7)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('3')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('4')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.urine_delete_toast).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for urine data "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Delete_urine_entry_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_Delete_urine_entry_customsummary(self):
        '''
        This function verify the day summary urine value
        :return:
        '''
        print(" Execution Started : verify_Delete_urine_entry_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6398"
        driver = desired_caps_IOS(self.serial)
        time.sleep(7)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.catheter).send_keys('3')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('4')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.urine_delete_toast).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for urine data "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Delete_urine_entry_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_Delete_icon_urine_naturally_entry_daysummary(self):
        '''
        This function verify the day summary urine value
        :return:
        '''
        print(" Execution Started : verify_Delete_icon_urine_naturally_entry_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6387"
        driver = desired_caps_IOS(self.serial)
        time.sleep(7)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('4')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Indetail_day_in_custom).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for urine data "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Delete_icon_urine_naturally_entry_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_Delete_icon_urine_naturally_entry_weeksummary(self):
        '''
        This function verify the day summary urine value
        :return:
        '''
        print(" Execution Started : verify_Delete_icon_urine_naturally_entry_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6388"
        driver = desired_caps_IOS(self.serial)
        time.sleep(7)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('4')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Indetail_day_in_custom).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.urine_delete_toast).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for urine data "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Delete_icon_urine_naturally_entry_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_Delete_icon_urine_naturally_entry_monthsummary(self):
        '''
        This function verify the day summary urine value
        :return:
        '''
        print(" Execution Started : verify_Delete_icon_urine_naturally_entry_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6389"
        driver = desired_caps_IOS(self.serial)
        time.sleep(7)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('4')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Latest_month_top).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.urine_delete_toast).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for urine data "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Delete_icon_urine_naturally_entry_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_Delete_icon_urine_naturally_entry_customsummary(self):
        '''
        This function verify the day summary urine value
        :return:
        '''
        print(" Execution Started : verify_Delete_icon_urine_naturally_entry_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6390"
        driver = desired_caps_IOS(self.serial)
        time.sleep(7)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('4')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.urine_delete_toast).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for urine data "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Delete_icon_urine_naturally_entry_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_Delete_icon_urine_catheter_entry_daysummary(self):
        '''
        This function verify the day summary urine value
        :return:
        '''
        print(" Execution Started : verify_Delete_icon_urine_catheter_entry_daysummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6391"
        driver = desired_caps_IOS(self.serial)
        time.sleep(7)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('4')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Indetail_day_in_custom).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for urine data "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Delete_icon_urine_catheter_entry_daysummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_Delete_icon_urine_catheter_entry_weeksummary(self):
        '''
        This function verify the day summary urine value
        :return:
        '''
        print(" Execution Started : verify_Delete_icon_urine_catheter_entry_weeksummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6392"
        driver = desired_caps_IOS(self.serial)
        time.sleep(7)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('4')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.week_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Indetail_day_in_custom).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.urine_delete_toast).is_displayed()
            if goal:
                status = PASS
                status_reason =  TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for urine data "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Delete_icon_urine_catheter_entry_weeksummary ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_Delete_icon_urine_catheter_entry_monthsummary(self):
        '''
        This function verify the day summary urine value
        :return:
        '''
        print(" Execution Started : verify_Delete_icon_urine_catheter_entry_monthsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6393"
        driver = desired_caps_IOS(self.serial)
        time.sleep(7)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('4')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.month_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.Latest_month_top).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.urine_delete_toast).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for urine data "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Delete_icon_urine_catheter_entry_monthsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_Delete_icon_urine_catheter_entry_customsummary(self):
        '''
        This function verify the day summary urine value
        :return:
        '''
        print(" Execution Started : verify_Delete_icon_urine_catheter_entry_customsummary")
        status = NOT_EXECUTED
        actual_result = None
        status_reason = None
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "6394"
        driver = desired_caps_IOS(self.serial)
        time.sleep(7)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.user_dashboard).click()
            time.sleep(1)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.record_entry).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.naturally).send_keys('4')
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.void).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.save).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.ok).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.custom_dropdown).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_start_date).click()
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_end_date).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.date_done).click()
            time.sleep(1)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.custom_dates_apply).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_CLASS_CHAIN, Ios_franklin_Constants.week_indetail_logs).click()
            time.sleep(2)
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.summary_edit_delete).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.urine_delete_toast).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Not able to set record entry for urine data "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            
            print(az_id, "verify_Delete_icon_urine_catheter_entry_customsummary ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_menu_share_logs_text(self):
        '''
        This function verify the share logs text
        :return:
        '''
        print(" Execution Started : verify_menu_share_logs_text")
        status = NOT_EXECUTED
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "8364"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "share text is not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            print(az_id, "verify_menu_share_logs_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_click_menu_share_logs_text(self):
        '''
        This function verify the share logs text
        :return:
        '''
        print(" Execution Started : verify_click_menu_share_logs_text")
        status = NOT_EXECUTED
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.Email).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to click on share logs "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            print(az_id, "verify_click_menu_share_logs_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_symbol_menu_share_logs_text(self):
        '''
        This function verify the share logs text
        :return:
        '''
        print(" Execution Started : verify_symbol_menu_share_logs_text")
        status = NOT_EXECUTED
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "8363"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to display the forward arrow symbol on share logs "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            print(az_id, "verify_symbol_menu_share_logs_text ", status, testcase_execution_time)
        return az_id, status, status_reason


    def verify_email_text_menu_share_logs(self):
        '''
        This function verify the share logs text
        :return:
        '''
        print(" Execution Started : verify_email_text_menu_share_logs")
        status = NOT_EXECUTED
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.Email).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "Unable to display the forward arrow symbol on share logs "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            print(az_id, "verify_email_text_menu_share_logs ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_share_logs_Email_field_share_logs(self):
        '''
        This function verify the share logs text
        :return:
        '''
        print(" Execution Started : verify_share_logs_Email_field_share_logs")
        status = NOT_EXECUTED
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.cancel_share_logs).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "email button not displaying "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            print(az_id, "verify_share_logs_Email_field_share_logs ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_cancel_text_menu_share_logs(self):
        '''
        This function verify the share logs text
        :return:
        '''
        print(" Execution Started : verify_cancel_text_menu_share_logs")
        status = NOT_EXECUTED
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.cancel_share_logs).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "cancel button not displaying "
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            print(az_id, "verify_cancel_text_menu_share_logs ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_cancel_text_menu_share_logs(self):
        '''
        This function verify the share logs text
        :return:
        '''
        print(" Execution Started : verify_click_cancel_text_menu_share_logs")
        status = NOT_EXECUTED
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.cancel_share_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "unable to click on cancel button"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            print(az_id, "verify_click_cancel_text_menu_share_logs ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_share_logs_text_menu_share_logs(self):
        '''
        This function verify the share logs text
        :return:
        '''
        print(" Execution Started : verify_share_logs_text_menu_share_logs")
        status = NOT_EXECUTED
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs).click()
            time.sleep(2)
            goal = driver.find_element(AppiumBy.IOS_PREDICATE,
                                       Ios_franklin_Constants.share_logs_text_sharelogs_screen).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "share logs button not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            print(az_id, "verify_share_logs_text_menu_share_logs ", status, testcase_execution_time)
        return az_id, status, status_reason

    def verify_click_share_logs_text_menu_share_logs(self):
        '''
        This function verify the share logs text
        :return:
        '''
        print(" Execution Started : verify_click_share_logs_text_menu_share_logs")
        status = NOT_EXECUTED
        tc_time_interval = None
        tc_start_time = get_current_time()
        az_id = "4321"
        driver = desired_caps_IOS(self.serial)
        time.sleep(2)
        try:
            driver.find_element(AppiumBy.ACCESSIBILITY_ID, Ios_franklin_Constants.menu).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs).click()
            time.sleep(2)
            driver.find_element(AppiumBy.IOS_PREDICATE, Ios_franklin_Constants.share_logs_text_sharelogs_screen).click()
            time.sleep(4)
            goal = driver.find_element(AppiumBy.ACCESSIBILITY_ID,
                                       Ios_franklin_Constants.successful_share_logs).is_displayed()
            if goal:
                status = PASS
                status_reason = TEST_SUCCESSFUL
            else:
                status = FAIL
                status_reason = "share logs button not displaying"
        except Exception as error:
            status = NOT_EXECUTED
            status_reason = str(error)
        finally:
            testcase_execution_time = execution_time(tc_start_time)
            print(az_id, "verify_click_share_logs_text_menu_share_logs ", status, testcase_execution_time)
        return az_id, status, status_reason

